webpackJsonp([5],{

/***/ 256:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_function_debounce__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_function_debounce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_function_debounce__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_function_bind__ = __webpack_require__(418);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_function_bind___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_function_bind__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__page_manager__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_gift_certificate_validator__ = __webpack_require__(401);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__cart_shipping_estimator__ = __webpack_require__(413);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__global_modal__ = __webpack_require__(66);
function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called')}return call&&(typeof call==='object'||typeof call==='function')?call:self}function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+typeof superClass)}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass}var Cart=function(_PageManager){_inherits(Cart,_PageManager);function Cart(){_classCallCheck(this,Cart);return _possibleConstructorReturn(this,_PageManager.apply(this,arguments))}Cart.prototype.loaded=function loaded(next){this.$cartContent=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-content]');this.$cartMessages=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-status]');this.$cartTotals=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-totals]');this.$overlay=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart] .loadingOverlay').hide();// TODO: temporary until roper pulls in his cart components
this.bindEvents();next()};Cart.prototype.cartUpdate=function cartUpdate($target){var _this2=this;var itemId=$target.data('cart-itemid');var $el=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('#qty-'+itemId);var oldQty=parseInt($el.val(),10);var maxQty=parseInt($el.data('quantity-max'),10);var minQty=parseInt($el.data('quantity-min'),10);var minError=$el.data('quantity-min-error');var maxError=$el.data('quantity-max-error');var newQty=$target.data('action')==='inc'?oldQty+1:oldQty-1;// Does not quality for min/max quantity
if(newQty<minQty){return alert(minError)}else if(maxQty>0&&newQty>maxQty){return alert(maxError)}this.$overlay.show();__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.itemUpdate(itemId,newQty,function(err,response){_this2.$overlay.hide();if(response.data.status==='succeed'){// if the quantity is changed "1" from "0", we have to remove the row.
var remove=newQty===0;_this2.refreshContent(remove)}else{$el.val(oldQty);alert(response.data.errors.join('\n'))}})};Cart.prototype.cartRemoveItem=function cartRemoveItem(itemId){var _this3=this;this.$overlay.show();__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.itemRemove(itemId,function(err,response){if(response.data.status==='succeed'){_this3.refreshContent(true)}else{alert(response.data.errors.join('\n'))}})};Cart.prototype.cartEditOptions=function cartEditOptions(itemId){var _this4=this;var modal=__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__global_modal__["a" /* defaultModal */])();var options={template:'cart/modals/configure-product'};modal.open();__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.productAttributes.configureInCart(itemId,options,function(err,response){modal.updateContent(response.content);_this4.bindGiftWrappingForm()});__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].hooks.on('product-option-change',function(event,option){var $changedOption=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(option);var $form=$changedOption.parents('form');var $submit=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('input.button',$form);var $messageBox=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.alertMessageBox');var item=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[name="item_id"]',$form).attr('value');__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.productAttributes.optionChange(item,$form.serialize(),function(err,result){var data=result.data||{};if(err){alert(err);return false}if(data.purchasing_message){__WEBPACK_IMPORTED_MODULE_3_jquery___default()('p.alertBox-message',$messageBox).text(data.purchasing_message);$submit.prop('disabled',true);$messageBox.show()}else{$submit.prop('disabled',false);$messageBox.hide()}if(!data.purchasable||!data.instock){$submit.prop('disabled',true)}else{$submit.prop('disabled',false)}})})};Cart.prototype.refreshContent=function refreshContent(remove){var _this5=this;var $cartItemsRows=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-item-row]',this.$cartContent);var $cartPageTitle=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-page-title]');var options={template:{content:'cart/content',totals:'cart/totals',pageTitle:'cart/page-title',statusMessages:'cart/status-messages'}};this.$overlay.show();// Remove last item from cart? Reload
if(remove&&$cartItemsRows.length===1){return window.location.reload()}__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.getContent(options,function(err,response){_this5.$cartContent.html(response.content);_this5.$cartTotals.html(response.totals);_this5.$cartMessages.html(response.statusMessages);$cartPageTitle.replaceWith(response.pageTitle);_this5.bindEvents();_this5.$overlay.hide();var quantity=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-quantity]',_this5.$cartContent).data('cart-quantity')||0;__WEBPACK_IMPORTED_MODULE_3_jquery___default()('body').trigger('cart-quantity-update',quantity)})};Cart.prototype.bindCartEvents=function bindCartEvents(){var _this6=this;var debounceTimeout=400;var cartUpdate=__WEBPACK_IMPORTED_MODULE_1_lodash_function_bind___default()(__WEBPACK_IMPORTED_MODULE_0_lodash_function_debounce___default()(this.cartUpdate,debounceTimeout),this);var cartRemoveItem=__WEBPACK_IMPORTED_MODULE_1_lodash_function_bind___default()(__WEBPACK_IMPORTED_MODULE_0_lodash_function_debounce___default()(this.cartRemoveItem,debounceTimeout),this);// cart update
__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-cart-update]',this.$cartContent).on('click',function(event){var $target=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget);event.preventDefault();// update cart quantity
cartUpdate($target)});__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.cart-remove',this.$cartContent).on('click',function(event){var itemId=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).data('cart-itemid');var openTime=new Date;var result=confirm(__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).data('confirm-delete'));var delta=new Date-openTime;event.preventDefault();// Delta workaround for Chrome's "prevent popup"
if(!result&&delta>10){return}// remove item from cart
cartRemoveItem(itemId)});__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-item-edit]',this.$cartContent).on('click',function(event){var itemId=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).data('item-edit');event.preventDefault();// edit item in cart
_this6.cartEditOptions(itemId)})};Cart.prototype.bindPromoCodeEvents=function bindPromoCodeEvents(){var _this7=this;var $couponContainer=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code');var $couponForm=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-form');var $codeInput=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[name="couponcode"]',$couponForm);__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code-add').on('click',function(event){event.preventDefault();__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).hide();$couponContainer.show();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code-cancel').show();$codeInput.focus()});__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code-cancel').on('click',function(event){event.preventDefault();$couponContainer.hide();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code-cancel').hide();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.coupon-code-add').show()});$couponForm.on('submit',function(event){var code=$codeInput.val();event.preventDefault();// Empty code
if(!code){return alert($codeInput.data('error'))}__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.applyCode(code,function(err,response){if(response.data.status==='success'){_this7.refreshContent()}else{alert(response.data.errors.join('\n'))}})})};Cart.prototype.bindGiftCertificateEvents=function bindGiftCertificateEvents(){var _this8=this;var $certContainer=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-code');var $certForm=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.cart-gift-certificate-form');var $certInput=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[name="certcode"]',$certForm);__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-add').on('click',function(event){event.preventDefault();__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).toggle();$certContainer.toggle();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-cancel').toggle()});__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-cancel').on('click',function(event){event.preventDefault();$certContainer.toggle();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-add').toggle();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.gift-certificate-cancel').toggle()});$certForm.on('submit',function(event){var code=$certInput.val();event.preventDefault();if(!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_gift_certificate_validator__["a" /* default */])(code)){return alert($certInput.data('error'))}__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.applyGiftCertificate(code,function(err,resp){if(resp.data.status==='success'){_this8.refreshContent()}else{alert(resp.data.errors.join('\n'))}})})};Cart.prototype.bindGiftWrappingEvents=function bindGiftWrappingEvents(){var _this9=this;var modal=__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__global_modal__["a" /* defaultModal */])();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-item-giftwrap]').on('click',function(event){var itemId=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).data('item-giftwrap');var options={template:'cart/modals/gift-wrapping-form'};event.preventDefault();modal.open();__WEBPACK_IMPORTED_MODULE_5__bigcommerce_stencil_utils__["c" /* default */].api.cart.getItemGiftWrappingOptions(itemId,options,function(err,response){modal.updateContent(response.content);_this9.bindGiftWrappingForm()})})};Cart.prototype.bindGiftWrappingForm=function bindGiftWrappingForm(){__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.giftWrapping-select').change(function(event){var $select=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget);var id=$select.val();var index=$select.data('index');if(!id){return}var allowMessage=$select.find('option[value='+id+']').data('allow-message');__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.giftWrapping-image-'+index).hide();__WEBPACK_IMPORTED_MODULE_3_jquery___default()('#giftWrapping-image-'+index+'-'+id).show();if(allowMessage){__WEBPACK_IMPORTED_MODULE_3_jquery___default()('#giftWrapping-message-'+index).show()}else{__WEBPACK_IMPORTED_MODULE_3_jquery___default()('#giftWrapping-message-'+index).hide()}});__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.giftWrapping-select').trigger('change');function toggleViews(){var value=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('input:radio[name ="giftwraptype"]:checked').val();var $singleForm=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.giftWrapping-single');var $multiForm=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('.giftWrapping-multiple');if(value==='same'){$singleForm.show();$multiForm.hide()}else{$singleForm.hide();$multiForm.show()}}__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[name="giftwraptype"]').click(toggleViews);toggleViews()};Cart.prototype.bindEvents=function bindEvents(){this.bindCartEvents();this.bindPromoCodeEvents();this.bindGiftWrappingEvents();this.bindGiftCertificateEvents();// initiate shipping estimator module
this.shippingEstimator=new __WEBPACK_IMPORTED_MODULE_6__cart_shipping_estimator__["a" /* default */](__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-shipping-estimator]'))};return Cart}(__WEBPACK_IMPORTED_MODULE_2__page_manager__["a" /* default */]);/* harmony default export */ __webpack_exports__["default"] = (Cart);

/***/ }),

/***/ 357:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nod_validate__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nod_validate___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nod_validate__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nod_functions_min_max_validate__ = __webpack_require__(359);
// Hook our SCSS framework form field status classes into the nod validation system before use
__WEBPACK_IMPORTED_MODULE_0_nod_validate___default.a.classes.errorClass='form-field--error';__WEBPACK_IMPORTED_MODULE_0_nod_validate___default.a.classes.successClass='form-field--success';__WEBPACK_IMPORTED_MODULE_0_nod_validate___default.a.classes.errorMessageClass='form-inlineMessage';// Register validate functions
__WEBPACK_IMPORTED_MODULE_0_nod_validate___default.a.checkFunctions['min-max']=__WEBPACK_IMPORTED_MODULE_1__nod_functions_min_max_validate__["a" /* default */];/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_nod_validate___default.a);

/***/ }),

/***/ 358:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var forms={email:function email(value){var re=/^.+@.+\..+/;return re.test(value)},/**
     * Validates a password field
     * @param value
     * @returns {boolean}
     */password:function password(value){return this.notEmpty(value)},/**
     * validates if a field is empty
     * @param value
     * @returns {boolean}
     *
     */notEmpty:function notEmpty(value){return value.length>0}};/* harmony default export */ __webpack_exports__["a"] = (forms);

/***/ }),

/***/ 359:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_lang_isNaN__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_lang_isNaN___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_lang_isNaN__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
function minMaxValidate(minInputSelector,maxInputSelector){function validate(cb){var minValue=parseFloat(__WEBPACK_IMPORTED_MODULE_1_jquery___default()(minInputSelector).val());var maxValue=parseFloat(__WEBPACK_IMPORTED_MODULE_1_jquery___default()(maxInputSelector).val());if(maxValue>minValue||__WEBPACK_IMPORTED_MODULE_0_lodash_lang_isNaN___default()(maxValue)||__WEBPACK_IMPORTED_MODULE_0_lodash_lang_isNaN___default()(minValue)){return cb(true)}return cb(false)}return validate}/* harmony default export */ __webpack_exports__["a"] = (minMaxValidate);

/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {

var indexOfNaN = __webpack_require__(368);

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;


/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(238);

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
 * which returns `true` for `undefined` and other non-numeric values.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */
function isNaN(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
  return isNumber(value) && value != +value;
}

module.exports = isNaN;


/***/ }),

/***/ 362:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {
/**
 *
 *
 * nod v.2.0.12
 * Gorm Casper
 *
 *
 *
 * This is a short breakdown of the code to help you find your way around.
 *
 *
 * An `element` always refer to some input element defined by the user via the
 * `selector` key.
 *
 * A `metric` is the user created objects that is used to add checks to
 * nod.
 *
 * Each `element` will have at most one of a `listener`, a `checker`, a
 * `checkHandler`, and a `domNode` "attached" to it. The `listener` listens
 * for inputs or changes to the `element` and passes the new value on to to the
 * `checker` which performs its checks and passes the the results on to the
 * `checkHandler` which calculates the new state of the `element` which it
 * passes on to the `domNode` which will update the dom.
 *
 * The four main parts, the listener, the checker, the checkHandler, and the
 * domNode all communicate through the `mediator` by firing events identified
 * by a unique id. They do not know of each other's existance, and so no
 * communication flows directly between them.
 *
 * All listeners, checkers, handlers, and domNodes are grouped together in
 * `collections`, which are basically a glorified array that makes it easy
 * not to get duplicate items for each element (for instance two listeners
 * listening to the same element).
 *
 * The communication flow looks like this:
 * listener -> checker -> checkHandler -> domNode
 *
 * Between each part, you have the mediator.
 *
 *
 * `Metrics` are added by the user, which sets up the system above. Notice
 * that a metric can target multiple elements at once, and that there can
 * be overlaps. One metric definitely does not equal one element or one
 * check.
 *
 */

function nod (config) {
    var form,
        configuration   = {},
        mediator        = nod.makeMediator(),
        eventEmitter    = nod.makeEventEmitter(mediator),

        // Creating (empty) collections
        listeners       = nod.makeCollection(nod.makeListener),
        checkers        = nod.makeCollection(nod.makeChecker),
        checkHandlers   = nod.makeCollection(nod.makeCheckHandler),
        domNodes        = nod.makeCollection(nod.makeDomNode);

    /**
     * Entry point for the user. The user passes in an array of metrics (an
     * object containing a selector, a validate string/function, etc.) and it
     * gets processed from here.
     *
     * This function, is mostly about cleaning up what the user passed us.
     */
    function addMetrics (metrics) {
        // Make sure we are dealing with an array of metrics.
        var arrayMetrics = Array.isArray(metrics) ? metrics : [metrics];

        arrayMetrics.forEach(function (metric) {
            var validateArray, errorMessageArray,
                notArray = !Array.isArray(metric.validate);

            // If the 'validate' is not an array, then we're good to go.
            if (notArray) {
                addMetric(metric);

            // If it is an array (e.g., validate: ['email', 'max-length:10']),
            // then we need to split them up into multiple metrics, and add
            // them individually.
            } else {
                if (!Array.isArray(metric.errorMessage)) {
                    var errorMsg = 'If you pass in `validate:...` as an ' +
                        ' array, then `errorMessage:...` also needs to be an ' +
                        ' array. "' + metric.validate + '", and "' +
                        metric.errorMessage + '"';

                    throw Error(errorMsg);
                }

                // We store each as arrays, and then run through them,
                // overwriting each of the keys accordingly.
                validateArray     = metric.validate;
                errorMessageArray = metric.errorMessage;

                validateArray.forEach(function (validate, i) {
                    // Overwrite the array with the individual 'validate' and
                    // 'errorMessage'.
                    metric.validate     = validate;
                    metric.errorMessage = errorMessageArray[i];

                    addMetric(metric);
                });
            }
        });
    }

    function addMetric (metric) {
        var specialTriggers = [],

            // The function that will check the value of the element.
            checkFunction = nod.getCheckFunction(metric),

            // A list of elements that this metric will target.
            elements = nod.getElements(metric.selector),

            // A "set" here, refers to an obj with one listener, one checker,
            // and one checkHandler. Only every one for each element in the
            // dom.
            metricSets = elements.map(function (element) {
                return {
                    listener:       listeners.findOrMake(element,
                                                         mediator,
                                                         metric.triggerEvents,
                                                         configuration),
                    checker:        checkers.findOrMake(element, mediator),
                    checkHandler:   checkHandlers.findOrMake(element,
                                                             mediator,
                                                             configuration),
                    domNode:        domNodes.findOrMake(element,
                                                        mediator,
                                                        configuration)
                };
            });

        // Saved for later reference in case the user has a `tap` function
        // defined.
        checkFunction.validate = (typeof metric.validate === 'function')
            ? metric.validate.toString()
            : metric.validate;

        // Special cases. These `validates` affect each other, and their state
        // needs to update each time either of the elements' values change.
        if (metric.validate === 'one-of'
            || metric.validate === 'only-one-of'
            || metric.validate === 'some-radio') {
            specialTriggers.push(metric.selector);
        }

        if (typeof metric.validate === 'string'
            && metric.validate.indexOf('same-as') > -1) {
            specialTriggers.push(metric.validate.split(':')[1]);
        }

        // Helper function, used in the loop below.
        function subscribeToTriggers (checker, selector) {
            var triggerElements = nod.getElements(selector);

            triggerElements.forEach(function (element) {
                var listener = listeners.findOrMake(element,
                                                    mediator,
                                                    null,
                                                    configuration);

                checker.subscribeTo(listener.id);
            });
        }

        // Here we set up the "connections" between each of our main parts.
        // They communicate only through the mediator.
        metricSets.forEach(function (metricSet) {
            // :: Listener -> Checker

            // We want our checker to listen to the listener. A listener has an
            // id, which it uses when it fires events to the mediator (which
            // was set up when the listener was created).
            metricSet.checker.subscribeTo(metricSet.listener.id);

            // If the user set a `triggeredBy`, the checker need to listen to
            // changes on this element as well.
            // Same goes for special triggers that we set.
            subscribeToTriggers(metricSet.checker, metric.triggeredBy);
            subscribeToTriggers(metricSet.checker, specialTriggers);

            // :: Checker -> checkHandler

            var checkId = nod.unique();

            // We add the check function as one to be checked when the user
            // inputs something. (There might be more than this one).
            metricSet.checker.addCheck(checkFunction, checkId);

            // We want the check handler to listen for results from the checker
            metricSet.checkHandler.subscribeTo(checkId,
                                               metric.errorMessage,
                                               metric.defaultStatus);

            if (configuration.noDom) {
                eventEmitter.subscribe(metricSet.checkHandler.id);
            } else {
                // :: checkHandler -> domNode

                // The checkHandler has its own id (and only ever needs one), so
                // we just ask the domNode to listen for that.
                metricSet.domNode.subscribeTo(metricSet.checkHandler.id);
            }
        });

        // After all is done, we may have to enable/disable a submit button.
        toggleSubmit();
    }

    /**
     * If a form is added, we listen for submits, and if the has also set
     * `preventSubmit` in the configuration, then we stop the commit from
     * happening unless all the elements are valid.
     */
    function addForm (selector) {
        var form = nod.getElement(selector);

        form.addEventListener('submit', possiblePreventSubmit, false);
    }

    // Prevent function, used above
    function possiblePreventSubmit (event) {
        if (configuration.preventSubmit && !areAll(nod.constants.VALID)) {
            event.preventDefault();

            // Show errors to the user
            checkers.forEach(function (checker) {
                checker.performCheck({
                    event: event
                });
            });

            // Focus on the first invalid element
            for (var i = 0, len = checkHandlers.length; i < len; i++) {
                var checkHandler = checkHandlers[i];

                if (checkHandler.getStatus().status === nod.constants.INVALID) {
                    checkHandler.element.focus();
                    break;
                }
            }
        }
    }

    /**
     * Removes elements completely.
     */
    function removeElement (selector) {
        var elements = nod.getElements(selector);

        elements.forEach(function (element) {
            listeners.removeItem(element);
            checkers.removeItem(element);
            checkHandlers.removeItem(element);
            domNodes.removeItem(element);
        });
    }

    /**
     * configure
     *
     * Changes the configuration object used throughout the code for classes,
     * delays, messages, etc.
     *
     * It can either be called with a key/value pair (two arguments), or with
     * an object with key/value pairs.
     */
    function configure (key, value) {
        var attributes = {};

        if (arguments.length > 1) {
            attributes[key] = value;
        } else {
            attributes = key;
        }

        for (var k in attributes) {
            configuration[k] = attributes[k];
        }

        if (attributes.submit || attributes.disableSubmit) {
            toggleSubmit();
        }

        if (attributes.form) {
            addForm(attributes.form);
        }
    }

    /**
     * toggleSubmit
     *
     * Toggles the submit button (enabled if every element is valid, otherwise
     * disabled).
     */
    function toggleSubmit () {
        if (configuration.submit && configuration.disableSubmit) {
            nod.getElements(configuration.submit).forEach(function (submitBtn) {
                submitBtn.disabled = !areAll(nod.constants.VALID);
            });
        }
    }

    /**
     * Listen to all checks, and if the user has set in the configuration to
     * enable/disabled the submit button, we do that.
     */
    mediator.subscribe('all', toggleSubmit);

    function areAll (status) {
        for (var i = 0, len = checkHandlers.length; i < len; i++) {
            if (checkHandlers[i].getStatus().status !== status) {
                return false;
            }
        }

        return true;
    }

    function setMessageOptions (options) {
        options = Array.isArray(options) ? options : [options];

        options.forEach(function (option) {
            var elements = nod.getElements(option.selector);

            elements.forEach(function (element) {
                var domNode = domNodes.findOrMake(element,
                                                  mediator,
                                                  configuration);

                domNode.setMessageOptions(option.parent, option.errorSpan);
            });
        });
    }

    /**
     * Listen to all checks and allow the user to listen in, if he set a `tap`
     * function in the configuration.
     */
    mediator.subscribe('all', function (options) {
        if (typeof configuration.tap === 'function'
            && options.type === 'check') {
            configuration.tap(options);
        }
    });

    function getStatus (selector, showErrorMessage) {
        var element = nod.getElement(selector),
            status  = checkHandlers.findOrMake(element).getStatus();

        return showErrorMessage ? status : status.status;
    }

    function performCheck (selector) {
        var cs = selector
            ? nod.getElements(selector).map(checkers.findOrMake)
            : checkers;

        cs.forEach(function (checker) {
            checker.performCheck();
        });
    }

    function setInvalid (selector, errorMessage) {
        var element = nod.getElement(selector),
            domNode  = domNodes.findOrMake(element);

        domNode.set({
            result: nod.constants.INVALID,
            errorMessage: errorMessage || ''
        });
    }

    function setValid (selector) {
        var element = nod.getElement(selector),
            domNode  = domNodes.findOrMake(element);

        domNode.set({
            result: nod.constants.VALID,
            errorMessage: ''
        });
    }

    function setAllNodeValid () {
        for (var i = 0, len = domNodes.length; i < len; i++) {
            setValid(domNodes[i].element);
        }
    }

    /**
     * Internal functions that are exposed to the public.
     */
    var nodInstace = {
        add:                    addMetrics,
        remove:                 removeElement,
        areAll:                 areAll,
        getStatus:              getStatus,
        configure:              configure,
        setMessageOptions:      setMessageOptions,
        performCheck:           performCheck,
        setInvalid:             setInvalid,
        setValid:               setValid,
        setAllNodeValid:        setAllNodeValid
    };

    if (config) {
        nodInstace.configure(config);
    }

    return nodInstace;
}

nod.constants = {
    VALID:          'valid',
    INVALID:        'invalid',
    UNCHECKED:      'unchecked',

    DELAY:          700
};

nod.classes = {
    successClass:         'nod-success',
    successMessageClass:  'nod-success-message',
    errorClass:           'nod-error',
    errorMessageClass:    'nod-error-message'
};

// Helper function to create unique id's
nod.unique = (function () {
    var uniqueCounter = 0;

    return function () {
        return uniqueCounter++;
    };
})();

/** makeMediator
 *
 * Minimal implementation of a mediator pattern, used for communication between
 * checkers and checkHandlers (checkers fires events which handlers can
 * subscribe to). Unique ID's are used to tell events apart.
 *
 * Subscribing to 'all' will give you all results from all checks.
 */
nod.makeMediator = function () {
    var subscribers = [],
        all = [];

    return {
        subscribe: function subscribe (id, fn) {
            if (id === 'all') {
                all.push(fn);
            } else {
                if (!subscribers[id]) {
                    subscribers[id] = [];
                }

                if (subscribers[id].indexOf(fn) === -1) {
                    subscribers[id].push(fn);
                }
            }
        },

        fire: function fire (options) {
            var subscribedFunctions = subscribers[options.id].concat(all);

            subscribedFunctions.forEach(function (subscribedFunction) {
                subscribedFunction(options);
            });
        }
    };
};

nod.findCollectionIndex = function (collection, element) {
    for (var i in collection) {
        if (collection[i].element === element) {
            return i;
        }
    }

    return -1;
};

/**
 * makeCollection
 *
 * A minimal implementation of a "collection", inspired by collections from
 * BackboneJS. Used by listeners, checkers, and checkHandlers.
 */
nod.makeCollection = function (maker) {
    var collection = [];

    collection.findOrMake = function (element) {
        var index = nod.findCollectionIndex(collection, element);

        // Found
        if (index !== -1) {
            return collection[index];
        }

        // None found, let's make one then.
        var item = maker.apply(null, arguments);

        collection.push(item);

        return item;
    };

    collection.removeItem = function (element) {
        var index = nod.findCollectionIndex(collection, element),
            item = collection[index];

        if (!item) {
            return;
        }

        // Call .dispose() if it exists
        if (typeof item.dispose === 'function') {
            item.dispose();
        }

        // Remove item
        collection.splice(index, 1);
    };

    return collection;
};

/**
 * makeListener
 *
 * Takes care of listening to changes to its element and fire them off as
 * events on the mediator for checkers to listen to.
 */
nod.makeListener = function (element, mediator, triggerEvents, configuration) {
    var id = nod.unique(),
        $element;

    function changed (event) {
        mediator.fire({
            id:     id,
            event:  event,
            type:   'change'
        });
    }

    element.addEventListener('input', changed, false);
    element.addEventListener('change', changed, false);
    element.addEventListener('blur', changed, false);

    if (configuration.jQuery) {
        $element = configuration.jQuery(element);

        $element.on('propertychange change click keyup input paste', changed);
    }

    if (triggerEvents) {
        triggerEvents = Array.isArray(triggerEvents)
            ? triggerEvents
            : [triggerEvents];

        triggerEvents.forEach(function (eventName) {
            element.addEventListener(eventName, changed, false);
        });
    }

    function dispose () {
        element.removeEventListener('input', changed, false);
        element.removeEventListener('change', changed, false);
        element.removeEventListener('blur', changed, false);

        if ($element) {
            $element.off();
        }

        if (triggerEvents) {
            triggerEvents.forEach(function (eventName) {
                element.removeEventListener(eventName, changed, false);
            });
        }
    }

    return {
        element:    element,
        dispose:    dispose,
        id:         id
    };
};

/**
 * makeChecker
 *
 * An "checker" communicates primarily with the mediator. It listens for input
 * changes (coming from listeners), performs its checks and fires off results
 * back to the mediator for checkHandlers to handle.
 *
 * The checker has a 1 to 1 relationship with an element, an listeners, and an
 * checkHandler; although they may communicate with other "sets" of listeners,
 * checkers and handlers.
 *
 * Checks are added, from the outside, and consists of a checkFunction (see
 * nod.checkFunctions) and a unique id.
 */
nod.makeChecker = function (element, mediator) {
    var checks = [];

    function subscribeTo (id) {
        mediator.subscribe(id, performCheck);
    }

    // Run every check function against the value of the element.
    function performCheck (options) {
        checks.forEach(function (check) {
            check(options || {});
        });
    }

    // Add a check function to the element. The result will be handed off to the
    // mediator (for checkHandlers to evaluate).
    function addCheck (checkFunction, id) {
        function callback (result) {
            mediator.fire({
                id: id,
                type: 'check',
                result: result,
                element: element,
                validate: checkFunction.validate
            });
        }

        checks.push(function (options) {
            // If element.value is undefined, then we might be dealing with
            // another type of element; like <div contenteditable='true'>
            var value = element.value === undefined
                ? element.innerHTML
                : element.value;

            options.element = element;

            checkFunction(callback, value, options);
        });
    }

    return {
        subscribeTo:    subscribeTo,
        addCheck:       addCheck,
        performCheck:   performCheck,
        element:        element
    };
};

/**
 * makeCheckHandler
 *
 * Handles checks coming in from the mediator and takes care of calculating the
 * state and error messages.
 *
 * The checkHandlers lives in one to one with the element parsed in, and listens
 * for (usually) multiple error checks.
 */
nod.makeCheckHandler = function (element, mediator, configuration) {
    var results     = {},
        id          = nod.unique();

    function subscribeTo (id, errorMessage, defaultStatus) {
        // Create a representation of the type of error in the results object.
        if (!results[id]) {
            results[id] = {
                status: defaultStatus || nod.constants.UNCHECKED,
                errorMessage: errorMessage
            };
        }

        // Subscribe to error id.
        mediator.subscribe(id, checkHandler);
    }

    function checkHandler (result) {
        results[result.id].status = result.result
            ? nod.constants.VALID
            : nod.constants.INVALID;

        notifyMediator();
    }

    // Runs through all results to see what kind of feedback to show the user.
    function notifyMediator () {
        var status = getStatus();

        // Event if might be valid we pass along an undefined errorMessage.
        mediator.fire({
            id:             id,
            type:           'result',
            result:         status.status,
            element:        element,
            errorMessage:   status.errorMessage
        });
    }

    function getStatus () {
        var status, errorMessage;

        for (var id in results) {
            status = results[id].status;

            if (results[id].status === nod.constants.INVALID) {
                errorMessage = results[id].errorMessage;
                break;
            }
        }

        return {
            status:        status,
            errorMessage:  errorMessage
        };
    }

    return {
        id:             id,
        subscribeTo:    subscribeTo,
        checkHandler:   checkHandler,
        getStatus:      getStatus,
        element:        element
    };
};

// Helper functions for `makeDomNode`.
nod.hasClass = function (className, el) {
    if (el.classList) {
        return el.classList.contains(className);
    } else {
        var regex = new RegExp('(\\s|^)' + className + '(\\s|$)');
        return !!el.className.match(regex);
    }
};

nod.removeClass = function (className, el) {
    if (el.classList) {
        el.classList.remove(className);
    } else if (nod.hasClass(className, el)) {
        var regex = new RegExp('(?:^|\\s)' + className + '(?!\\S)');
        el.className = el.className.replace(regex, '');
    }
};

nod.addClass = function (className, el) {
    if (el.classList) {
        el.classList.add(className);
    } else if (!nod.hasClass(className, el)) {
        el.className += ' ' + className;
    }
};

nod.getParent = function (element, configuration) {
    var klass = configuration.parentClass;

    if (klass) {
        klass = klass.charAt(0) === '.' ? klass.slice(1) : klass;
        return nod.findParentWithClass(element.parentNode, klass);
    } else {
        return element.parentNode;
    }
};

nod.findParentWithClass = function (parent, klass) {
    // Guard (only the `window` does not have a parent).
    if (!parent.parentNode) {
        return parent;
    }

    // Found it
    if (nod.hasClass(klass, parent)) {
        return parent;
    }

    // Try next parent (recursion)
    return nod.findParentWithClass(parent.parentNode, klass);
};

/**
 * makeDomNode
 *
 * This creates the error/success message behind the input element, as well as
 * takes care of updating classes and taking care of its own state.
 *
 * The dom node is owned by checkHandler, and has a one to one relationship with
 * both the checkHandler and the input element being checked.
 *
 */
nod.makeDomNode = function (element, mediator, configuration) {
    // A 'domNode' consists of two elements: a 'parent', and a 'span'. The
    // parent is given as a paremeter, while the span is created and added as a
    // child to the parent.
    var parent              = nod.getParent(element, configuration),
        _status             = nod.constants.UNCHECKED,
        pendingUpdate       = null,
        span                = document.createElement('span'),
        customSpan          = false;

    span.style.display = 'none';

    if (!configuration.noDom) {
        parent.appendChild(span);
    }

    // Updates the class of the parent to match the status of the element.
    function updateParent (status) {
        var successClass = configuration.successClass
                           || nod.classes.successClass,
            errorClass = configuration.errorClass
                         || nod.classes.errorClass;

        switch (status) {
        case nod.constants.VALID:
            nod.removeClass(errorClass, parent);
            nod.addClass(successClass, parent);
            break;

        case nod.constants.INVALID:
            nod.removeClass(successClass, parent);
            nod.addClass(errorClass, parent);
            break;
        }
    }

    // Updates the text and class according to the status.
    function updateSpan (status, errorMessage) {
        var successMessageClass = configuration.successMessageClass
                                  || nod.classes.successMessageClass,
          errorMessageClass   = configuration.errorMessageClass
                                || nod.classes.errorMessageClass;

        span.style.display = 'none';

        switch (status) {
        case nod.constants.VALID:
            nod.removeClass(errorMessageClass, span);
            nod.addClass(successMessageClass, span);

            if (configuration.successMessage) {
                span.textContent = configuration.successMessage;
                span.style.display = '';
            }

            break;

        case nod.constants.INVALID:
            nod.removeClass(successMessageClass, span);
            nod.addClass(errorMessageClass, span);
            span.textContent = errorMessage;
            span.style.display = '';
            break;
        }
    }

    function set (options) {
        var status              = options.result,
            errorMessage        = options.errorMessage;

        // If the dom is showing an invalid message, we want to update the dom
        // right away.
        if (_status === nod.constants.INVALID || configuration.delay === 0) {
            _status = status;
            updateParent(status);
            updateSpan(status, errorMessage);
        } else {
            // If the dom shows either an unchecked or a valid state we won't
            // rush to tell them they are wrong. Instead we use a method similar
            // to "debouncing" the update
            clearTimeout(pendingUpdate);

            pendingUpdate = setTimeout(function () {
                _status = status;
                updateParent(status);
                updateSpan(status, errorMessage);
                pendingUpdate = null;
            }, configuration.delay || nod.constants.DELAY);
        }
    }

    function subscribeTo (id) {
        mediator.subscribe(id, set);
    }

    function setMessageOptions (parentContainer, message) {
        if (parentContainer) {
            parent = nod.getElement(parentContainer);
        }

        if (message) {
            span.parentNode.removeChild(span);      // Remove old span.
            span = nod.getElement(message);         // Set the new one.
            customSpan = true;                      // So we won't delete it.
        }
    }

    function dispose () {
        // First remove any classes
        nod.removeClass(configuration.errorClass
                        || nod.classes.errorClass, parent);
        nod.removeClass(configuration.successClass
                        || nod.classes.successClass, parent);

        // Then we remove the span if it wasn't one that was set by the user.
        // If `noDom` was used, then there won't be any to remove.
        if (span.parentNode && !customSpan) {
            span.parentNode.removeChild(span);
        }
    }

    return {
        subscribeTo:        subscribeTo,
        element:            element,
        setMessageOptions:  setMessageOptions,
        dispose:            dispose,
        set:                set
    };
};

nod.makeEventEmitter = function (mediator) {
    var customEvent;

    function emit (options) {
        if (CustomEvent) {
            customEvent = new CustomEvent('nod.validation', {detail: options});

            options.element.dispatchEvent(customEvent);
        } else {
            var errorMsg = 'nod.validate tried to fire a custom event, but ' +
                           'the browser does not support CustomEvent\'s';

            throw Error(errorMsg);
        }
    }

    function subscribe (id) {
        mediator.subscribe(id, emit);
    }

    return {
        subscribe: subscribe
    };
};

/**
 * getElement
 *
 * Returns the first element targeted by the selector. (see `getElements`)
 */
nod.getElement = function (selector) {
    return nod.getElements(selector)[0];
};

/**
 * getElements
 *
 * Takes some sort of selector, and returns an array of element(s). The applied
 * selector can be one of:
 *
 * - Css type selector (e.g., ".foo")
 * - A jQuery element (e.g., $('.foo))
 * - A single raw dom element (e.g., document.getElementById('foo'))
 * - A list of raw dom element (e.g., $('.foo').get())
 */
nod.getElements = function (selector) {
    if (!selector) {
        return [];
    }

    // Normal css type selector is assumed
    if (typeof selector === 'string') {
        // If we have jQuery, then we use that to create a dom list for us.
        if (__webpack_provided_window_dot_jQuery) {
            return __webpack_provided_window_dot_jQuery(selector).get();
        }

        // If not, then we do it the manual way.
        var nodeList = document.querySelectorAll(selector);

        return [].map.call(nodeList, function (el) {
            return el;
        });
    }

    // if user gave us jQuery elements
    if (selector.jquery) {
        return selector.get();
    }

    // Raw DOM element
    if (selector.nodeType === 1) {
        return [selector];
    }

    if (Array.isArray(selector)) {
        var result = [];

        selector.forEach(function (sel) {
            var elements = nod.getElements(sel);

            result = result.concat(elements);
        });

        return result;
    }

    throw Error('Unknown type of elements in your `selector`: ' + selector);
};

nod.getCheckFunction = function (metric) {
    if (typeof metric.validate === 'function') {
        return metric.validate;
    }

    if (metric.validate instanceof RegExp) {
        return nod.checkFunctions.regexp(metric.validate);
    }

    var args   = metric.validate.split(':'),
        fnName = args.shift();

    if (fnName === 'one-of' || fnName === 'only-one-of' ||
        fnName === 'same-as' || fnName === 'some-radio') {
        args.push(metric.selector);
    }

    if (typeof nod.checkFunctions[fnName] === 'function') {
        return nod.checkFunctions[fnName].apply(null, args);
    } else {
        var errorMsg = 'Couldn\'t find your validator function "' +
                       fnName + '" for "' + metric.selector + '"';

        throw Error(errorMsg);
    }
};

// Collection of built-in check functions
nod.checkFunctions = {
    'presence': function () {
        return function presence (callback, value) {
            callback(value.length > 0);
        };
    },

    'exact': function (exactValue) {
        return function exact (callback, value) {
            callback(value === exactValue);
        };
    },

    'contains': function (containsValue) {
        return function contains (callback, value) {
            callback(value.indexOf(containsValue) > -1);
        };
    },

    'not': function (exactValue) {
        return function not (callback, value) {
            callback(value !== exactValue);
        };
    },

    'min-length': function (minimumLength) {
        return function minLength (callback, value) {
            callback(value.length >= minimumLength);
        };
    },

    'max-length': function (maximumLength) {
        return function maxLength (callback, value) {
            callback(value.length <= maximumLength);
        };
    },

    'exact-length': function (exactLen) {
        return function exactLength (callback, value) {
            callback(value.length === +exactLen);
        };
    },

    'between-length': function (minimumLength, maximumLength) {
        return function betweenLength (callback, value) {
            var aboveMinLength = value.length >= minimumLength,
                belowMaxLength = value.length <= maximumLength;

            callback(aboveMinLength && belowMaxLength);
        };
    },

    'max-number': function (maximumNumber) {
        return function maxNumber (callback, value) {
            callback(+value <= maximumNumber);
        };
    },

    'min-number': function (minimumNumber) {
        return function minNumber (callback, value) {
            callback(+value >= minimumNumber);
        };
    },

    'between-number': function (minimumNumber, maximumNumber) {
        return function betweenNumber (callback, value) {
            callback(+value >= minimumNumber && +value <= maximumNumber);
        };
    },

    'integer': function () {
        return function (callback, value) {
            callback(/^\s*\d+\s*$/.test(value));
        };
    },

    'float': function () {
        return function (callback, value) {
            callback(/^[-+]?[0-9]+(\.[0-9]+)?$/.test(value));
        };
    },

    'same-as': function (selector) {
        var sameAsElement = nod.getElement(selector);

        return function sameAs (callback, value, options) {
            // 'same-as' is special, in that if it is triggered by another field
            // (the one it should be similar to), and the field itself is empty,
            // then it bails out without a check. This is to avoid showing an
            // error message before the user has even reached the element.
            if (options &&
                options.event &&
                options.event.target &&
                options.event.target !== options.element &&
                value.length === 0) {
                return;
            }

            callback(value === sameAsElement.value);
        };
    },

    'one-of': function (selector) {
        var elements = nod.getElements(selector);

        function getValues () {
            return elements.reduce(function (memo, element) {
                return memo + '' + (element.value || '');
            }, '');
        }

        return function oneOf (callback) {
            callback(getValues().trim().length > 0);
        };
    },

    'only-one-of': function (selector) {
        var elements = nod.getElements(selector);

        return function onlyOneOf (callback, value) {
            var numOfValues = 0;

            elements.forEach(function (element) {
                if (element.value) {
                    numOfValues++;
                }
            });

            callback(numOfValues === 1);
        };
    },

    'checked': function () {
        return function checked (callback, value, options) {
            callback(options.element.checked);
        };
    },

    'some-radio': function (selector) {
        var radioElements = nod.getElements(selector);

        return function someRadio (callback, value, options) {
            var result = radioElements.reduce(function (memo, element) {
                return memo || element.checked;
            }, false);

            callback(result);
        };
    },

    'regexp': function (reg) {
        return function regExp (callback, value) {
            callback(reg.test(value));
        };
    },

    'email': function () {
        var RFC822 = /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/;

        return function email (callback, value) {
            callback(RFC822.test(value));
        };
    }
};

// CustomEvent polyfill for older IE versions. Taken from
// github.com/d4tocchini/customevent-polyfill/blob/master/CustomEvent.js
try {
    new CustomEvent("test");
} catch (e) {
    var CustomEvent = function (event, params) {
        var evt;
        params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };

        evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event,
                            params.bubbles,
                            params.cancelable,
                            params.detail);
        return evt;
    };

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
}

// Safely export nod.
if (typeof module !== 'undefined' && module.exports) {
    module.exports = nod;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),

/***/ 363:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = classifyForm;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Validators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return insertStateHiddenField; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_string_capitalize__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_string_capitalize___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_string_capitalize__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_string_camelCase__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_string_camelCase___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_string_camelCase__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_collection_contains__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_collection_contains___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_collection_contains__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__nod__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__models_forms__ = __webpack_require__(358);
var inputTagNames=['input','select','textarea'];/**
 * Apply class name to an input element on its type
 * @param {object} input
 * @param {string} formFieldClass
 * @return {object} Element itself
 */function classifyInput(input,formFieldClass){var $input=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(input);var $formField=$input.parent('.'+formFieldClass);var tagName=$input.prop('tagName').toLowerCase();var className=formFieldClass+'--'+tagName;var specificClassName=void 0;// Input can be text/checkbox/radio etc...
if(tagName==='input'){var inputType=$input.prop('type');if(__WEBPACK_IMPORTED_MODULE_2_lodash_collection_contains___default()(['radio','checkbox','submit'],inputType)){// ie: .form-field--checkbox, .form-field--radio
className=formFieldClass+'--'+__WEBPACK_IMPORTED_MODULE_1_lodash_string_camelCase___default()(inputType)}else{// ie: .form-field--input .form-field--inputText
specificClassName=''+className+__WEBPACK_IMPORTED_MODULE_0_lodash_string_capitalize___default()(inputType)}}// Apply class modifier
return $formField.addClass(className).addClass(specificClassName)}/**
 * Apply class name to each input element in a form based on its type
 * @example
 * // Before
 * <form id="form">
 *     <div class="form-field">
 *         <input type="text">
 *     </div>
 *     <div class="form-field">
 *         <select>...</select>
 *     </div>
 * </form>
 *
 * classifyForm('#form', { formFieldClass: 'form-field' });
 *
 * // After
 * <div class="form-field form-field--input form-field--inputText">...</div>
 * <div class="form-field form-field--select">...</div>
 *
 * @param {string|object} formSelector - selector or element
 * @param {object} options
 * @return {jQuery} Element itself
 */function classifyForm(formSelector){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var $form=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(formSelector);var $inputs=$form.find(inputTagNames.join(', '));// Obtain options
var _options$formFieldCla=options.formFieldClass,formFieldClass=_options$formFieldCla===undefined?'form-field':_options$formFieldCla;// Classify each input in a form
$inputs.each(function(__,input){classifyInput(input,formFieldClass)});return $form}/**
 * Get id from given field
 * @param {object} $field JQuery field object
 * @return {string}
 */function getFieldId($field){var fieldId=$field.prop('name').match(/(\[.*\])/);if(fieldId&&fieldId.length!==0){return fieldId[0]}return''}/**
 * Insert hidden field after State/Province field
 * @param {object} $stateField JQuery field object
 */function insertStateHiddenField($stateField){var fieldId=getFieldId($stateField);var stateFieldAttrs={type:'hidden',name:'FormFieldIsText'+fieldId,value:'1'};$stateField.after(__WEBPACK_IMPORTED_MODULE_3_jquery___default()('<input />',stateFieldAttrs))}var Validators={/**
     * Sets up a new validation when the form is dirty
     * @param validator
     * @param field
     */setEmailValidation:function setEmailValidation(validator,field){if(field){validator.add({selector:field,validate:function validate(cb,val){var result=__WEBPACK_IMPORTED_MODULE_5__models_forms__["a" /* default */].email(val);cb(result)},errorMessage:'You must enter a valid email.'})}},/**
     * Validate password fields
     * @param validator
     * @param passwordSelector
     * @param password2Selector
     * @param requirements
     * @param isOptional
     */setPasswordValidation:function setPasswordValidation(validator,passwordSelector,password2Selector,requirements,isOptional){var $password=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(passwordSelector);var passwordValidations=[{selector:passwordSelector,validate:function validate(cb,val){var result=val.length;if(isOptional){return cb(true)}cb(result)},errorMessage:'You must enter a password.'},{selector:passwordSelector,validate:function validate(cb,val){var result=val.match(new RegExp(requirements.alpha))&&val.match(new RegExp(requirements.numeric))&&val.length>=requirements.minlength;// If optional and nothing entered, it is valid
if(isOptional&&val.length===0){return cb(true)}cb(result)},errorMessage:requirements.error},{selector:password2Selector,validate:function validate(cb,val){var result=val.length;if(isOptional){return cb(true)}cb(result)},errorMessage:'You must enter a password.'},{selector:password2Selector,validate:function validate(cb,val){var result=val===$password.val();cb(result)},errorMessage:'Your passwords do not match.'}];validator.add(passwordValidations)},/**
     * Validate password fields
     * @param {Nod} validator
     * @param {Object} selectors
     * @param {string} selectors.errorSelector
     * @param {string} selectors.fieldsetSelector
     * @param {string} selectors.formSelector
     * @param {string} selectors.maxPriceSelector
     * @param {string} selectors.minPriceSelector
     */setMinMaxPriceValidation:function setMinMaxPriceValidation(validator,selectors){var errorSelector=selectors.errorSelector,fieldsetSelector=selectors.fieldsetSelector,formSelector=selectors.formSelector,maxPriceSelector=selectors.maxPriceSelector,minPriceSelector=selectors.minPriceSelector;validator.configure({form:formSelector,preventSubmit:true,successClass:'_'// KLUDGE: Don't apply success class
});validator.add({errorMessage:'Min price must be less than max. price.',selector:minPriceSelector,validate:'min-max:'+minPriceSelector+':'+maxPriceSelector});validator.add({errorMessage:'Min price must be less than max. price.',selector:maxPriceSelector,validate:'min-max:'+minPriceSelector+':'+maxPriceSelector});validator.add({errorMessage:'Max. price is required.',selector:maxPriceSelector,validate:'presence'});validator.add({errorMessage:'Min. price is required.',selector:minPriceSelector,validate:'presence'});validator.add({errorMessage:'Input must be greater than 0.',selector:[minPriceSelector,maxPriceSelector],validate:'min-number:0'});validator.setMessageOptions({selector:[minPriceSelector,maxPriceSelector],parent:fieldsetSelector,errorSpan:errorSelector})},/**
     * Sets up a new validation when the form is dirty
     * @param validator
     * @param field
     */setStateCountryValidation:function setStateCountryValidation(validator,field){if(field){validator.add({selector:field,validate:'presence',errorMessage:'The \'State/Province\' field cannot be blank.'})}},/**
     * Removes classes from dirty form if previously checked
     * @param field
     */cleanUpStateValidation:function cleanUpStateValidation(field){var $fieldClassElement=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-type="'+field.data('field-type')+'"]');Object.keys(__WEBPACK_IMPORTED_MODULE_4__nod__["a" /* default */].classes).forEach(function(value){if($fieldClassElement.hasClass(__WEBPACK_IMPORTED_MODULE_4__nod__["a" /* default */].classes[value])){$fieldClassElement.removeClass(__WEBPACK_IMPORTED_MODULE_4__nod__["a" /* default */].classes[value])}})}};

/***/ }),

/***/ 364:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(365);


/***/ }),

/***/ 365:
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(360),
    getLength = __webpack_require__(94),
    isArray = __webpack_require__(15),
    isIterateeCall = __webpack_require__(93),
    isLength = __webpack_require__(45),
    isString = __webpack_require__(240),
    values = __webpack_require__(369);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `target` is in `collection` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the offset
 * from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @alias contains, include
 * @category Collection
 * @param {Array|Object|string} collection The collection to search.
 * @param {*} target The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
 * @returns {boolean} Returns `true` if a matching element is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
 * // => true
 *
 * _.includes('pebbles', 'eb');
 * // => true
 */
function includes(collection, target, fromIndex, guard) {
  var length = collection ? getLength(collection) : 0;
  if (!isLength(length)) {
    collection = values(collection);
    length = collection.length;
  }
  if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
    fromIndex = 0;
  } else {
    fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
  }
  return (typeof collection == 'string' || !isArray(collection) && isString(collection))
    ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, target, fromIndex) > -1);
}

module.exports = includes;


/***/ }),

/***/ 366:
/***/ (function(module, exports) {

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  var index = -1,
      length = props.length,
      result = Array(length);

  while (++index < length) {
    result[index] = object[props[index]];
  }
  return result;
}

module.exports = baseValues;


/***/ }),

/***/ 367:
/***/ (function(module, exports, __webpack_require__) {

var deburr = __webpack_require__(372),
    words = __webpack_require__(373);

/**
 * Creates a function that produces compound words out of the words in a
 * given string.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    var index = -1,
        array = words(deburr(string)),
        length = array.length,
        result = '';

    while (++index < length) {
      result = callback(result, array[index], index);
    }
    return result;
  };
}

module.exports = createCompounder;


/***/ }),

/***/ 368:
/***/ (function(module, exports) {

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = indexOfNaN;


/***/ }),

/***/ 369:
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(366),
    keys = __webpack_require__(30);

/**
 * Creates an array of the own enumerable property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ 370:
/***/ (function(module, exports, __webpack_require__) {

var createCompounder = __webpack_require__(367);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar');
 * // => 'fooBar'
 *
 * _.camelCase('__foo_bar__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
});

module.exports = camelCase;


/***/ }),

/***/ 371:
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(237);

/**
 * Capitalizes the first character of `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('fred');
 * // => 'Fred'
 */
function capitalize(string) {
  string = baseToString(string);
  return string && (string.charAt(0).toUpperCase() + string.slice(1));
}

module.exports = capitalize;


/***/ }),

/***/ 372:
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 373:
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(237),
    isIterateeCall = __webpack_require__(93);

/** Used to match words to create compound words. */
var reWords = (function() {
  var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
      lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

  return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
}());

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  if (guard && isIterateeCall(string, pattern, guard)) {
    pattern = undefined;
  }
  string = baseToString(string);
  return string.match(pattern || reWords) || [];
}

module.exports = words;


/***/ }),

/***/ 376:
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(12);

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 381:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_collection_each__ = __webpack_require__(384);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_collection_each___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_collection_each__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_lang_isEmpty__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_lang_isEmpty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_lang_isEmpty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_object_transform__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_object_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_object_transform__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bigcommerce_stencil_utils__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__form_utils__ = __webpack_require__(363);
/**
 * If there are no options from bcapp, a text field will be sent. This will create a select element to hold options after the remote request.
 * @returns {jQuery|HTMLElement}
 */function makeStateRequired(stateElement,context){var attrs=__WEBPACK_IMPORTED_MODULE_2_lodash_object_transform___default()(stateElement.prop('attributes'),function(result,item){var ret=result;ret[item.name]=item.value;return ret});var replacementAttributes={id:attrs.id,'data-label':attrs['data-label'],class:'form-select',name:attrs.name,'data-field-type':attrs['data-field-type']};stateElement.replaceWith(__WEBPACK_IMPORTED_MODULE_3_jquery___default()('<select></select>',replacementAttributes));var $newElement=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-field-type="State"]');var $hiddenInput=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[name*="FormFieldIsText"]');if($hiddenInput.length!==0){$hiddenInput.remove()}if($newElement.prev().find('small').length===0){// String is injected from localizer
$newElement.prev().append('<small>'+context.required+'</small>')}else{$newElement.prev().find('small').show()}return $newElement}/**
 * If a country with states is the default, a select will be sent,
 * In this case we need to be able to switch to an input field and hide the required field
 */function makeStateOptional(stateElement){var attrs=__WEBPACK_IMPORTED_MODULE_2_lodash_object_transform___default()(stateElement.prop('attributes'),function(result,item){var ret=result;ret[item.name]=item.value;return ret});var replacementAttributes={type:'text',id:attrs.id,'data-label':attrs['data-label'],class:'form-input',name:attrs.name,'data-field-type':attrs['data-field-type']};stateElement.replaceWith(__WEBPACK_IMPORTED_MODULE_3_jquery___default()('<input />',replacementAttributes));var $newElement=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-field-type="State"]');if($newElement.length!==0){__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__form_utils__["c" /* insertStateHiddenField */])($newElement);$newElement.prev().find('small').hide()}return $newElement}/**
 * Adds the array of options from the remote request to the newly created select box.
 * @param {Object} statesArray
 * @param {jQuery} $selectElement
 * @param {Object} options
 */function addOptions(statesArray,$selectElement,options){var container=[];container.push('<option value="">'+statesArray.prefix+'</option>');if(!__WEBPACK_IMPORTED_MODULE_1_lodash_lang_isEmpty___default()($selectElement)){__WEBPACK_IMPORTED_MODULE_0_lodash_collection_each___default()(statesArray.states,function(stateObj){if(options.useIdForStates){container.push('<option value="'+stateObj.id+'">'+stateObj.name+'</option>')}else{container.push('<option value="'+stateObj.name+'">'+stateObj.name+'</option>')}});$selectElement.html(container.join(' '))}}/**
 *
 * @param {jQuery} stateElement
 * @param {Object} context
 * @param {Object} options
 * @param {Function} callback
 *//* harmony default export */ __webpack_exports__["a"] = (function(stateElement){var context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var options=arguments[2];var callback=arguments[3];/**
     * Backwards compatible for three parameters instead of four
     *
     * Available options:
     *
     * useIdForStates {Bool} - Generates states dropdown using id for values instead of strings
     */if(typeof options==='function'){/* eslint-disable no-param-reassign */callback=options;options={};/* eslint-enable no-param-reassign */}__WEBPACK_IMPORTED_MODULE_3_jquery___default()('select[data-field-type="Country"]').on('change',function(event){var countryName=__WEBPACK_IMPORTED_MODULE_3_jquery___default()(event.currentTarget).val();if(countryName===''){return}__WEBPACK_IMPORTED_MODULE_4__bigcommerce_stencil_utils__["c" /* default */].api.country.getByName(countryName,function(err,response){if(err){alert(context.state_error);return callback(err)}var $currentInput=__WEBPACK_IMPORTED_MODULE_3_jquery___default()('[data-field-type="State"]');if(!__WEBPACK_IMPORTED_MODULE_1_lodash_lang_isEmpty___default()(response.data.states)){// The element may have been replaced with a select, reselect it
var $selectElement=makeStateRequired($currentInput,context);addOptions(response.data,$selectElement,options);callback(null,$selectElement)}else{var newElement=makeStateOptional($currentInput,context);callback(null,newElement)}})})});

/***/ }),

/***/ 384:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(385);


/***/ }),

/***/ 385:
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(241),
    baseEach = __webpack_require__(244),
    createForEach = __webpack_require__(392);

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length" property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
var forEach = createForEach(arrayEach, baseEach);

module.exports = forEach;


/***/ }),

/***/ 392:
/***/ (function(module, exports, __webpack_require__) {

var bindCallback = __webpack_require__(68),
    isArray = __webpack_require__(15);

/**
 * Creates a function for `_.forEach` or `_.forEachRight`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over an array.
 * @param {Function} eachFunc The function to iterate over a collection.
 * @returns {Function} Returns the new each function.
 */
function createForEach(arrayFunc, eachFunc) {
  return function(collection, iteratee, thisArg) {
    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
      ? arrayFunc(collection, iteratee)
      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
  };
}

module.exports = createForEach;


/***/ }),

/***/ 393:
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(241),
    baseCallback = __webpack_require__(243),
    baseCreate = __webpack_require__(376),
    baseForOwn = __webpack_require__(96),
    isArray = __webpack_require__(15),
    isFunction = __webpack_require__(246),
    isObject = __webpack_require__(12),
    isTypedArray = __webpack_require__(247);

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own enumerable
 * properties through `iteratee`, with each invocation potentially mutating
 * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
 * with four arguments: (accumulator, value, key, object). Iteratee functions
 * may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Array|Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * });
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
 *   result[key] = n * 3;
 * });
 * // => { 'a': 3, 'b': 6 }
 */
function transform(object, iteratee, accumulator, thisArg) {
  var isArr = isArray(object) || isTypedArray(object);
  iteratee = baseCallback(iteratee, thisArg, 4);

  if (accumulator == null) {
    if (isArr || isObject(object)) {
      var Ctor = object.constructor;
      if (isArr) {
        accumulator = isArray(object) ? new Ctor : [];
      } else {
        accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
      }
    } else {
      accumulator = {};
    }
  }
  (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ 401:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(cert){if(typeof cert!=='string'){return false}// Add any custom gift certificate validation logic here
return true});

/***/ }),

/***/ 402:
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(376),
    baseLodash = __webpack_require__(403);

/** Used as references for `-Infinity` and `Infinity`. */
var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = POSITIVE_INFINITY;
  this.__views__ = [];
}

LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

module.exports = LazyWrapper;


/***/ }),

/***/ 403:
/***/ (function(module, exports) {

/**
 * The function whose prototype all chaining wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

module.exports = baseLodash;


/***/ }),

/***/ 404:
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(376),
    isObject = __webpack_require__(12);

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors.
    // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtorWrapper;


/***/ }),

/***/ 405:
/***/ (function(module, exports) {

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    if (array[index] === placeholder) {
      array[index] = PLACEHOLDER;
      result[++resIndex] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;


/***/ }),

/***/ 406:
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(376),
    baseLodash = __webpack_require__(403);

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
 * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
 */
function LodashWrapper(value, chainAll, actions) {
  this.__wrapped__ = value;
  this.__actions__ = actions || [];
  this.__chain__ = !!chainAll;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

module.exports = LodashWrapper;


/***/ }),

/***/ 407:
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(99),
    metaMap = __webpack_require__(411);

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;


/***/ }),

/***/ 408:
/***/ (function(module, exports) {

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders) {
  var holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      leftIndex = -1,
      leftLength = partials.length,
      result = Array(leftLength + argsLength);

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    result[holders[argsIndex]] = args[argsIndex];
  }
  while (argsLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;


/***/ }),

/***/ 409:
/***/ (function(module, exports) {

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders) {
  var holdersIndex = -1,
      holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      rightIndex = -1,
      rightLength = partials.length,
      result = Array(argsLength + rightLength);

  while (++argsIndex < argsLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    result[offset + holders[holdersIndex]] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgsRight;


/***/ }),

/***/ 410:
/***/ (function(module, exports, __webpack_require__) {

var metaMap = __webpack_require__(411),
    noop = __webpack_require__(429);

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;


/***/ }),

/***/ 411:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var getNative = __webpack_require__(67);

/** Native method references. */
var WeakMap = getNative(global, 'WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),

/***/ 412:
/***/ (function(module, exports, __webpack_require__) {

var baseSetData = __webpack_require__(407),
    now = __webpack_require__(249);

/** Used to detect when a function becomes hot. */
var HOT_COUNT = 150,
    HOT_SPAN = 16;

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity function
 * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = (function() {
  var count = 0,
      lastCalled = 0;

  return function(key, value) {
    var stamp = now(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return key;
      }
    } else {
      count = 0;
    }
    return baseSetData(key, value);
  };
}());

module.exports = setData;


/***/ }),

/***/ 413:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_state_country__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_nod__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bigcommerce_stencil_utils__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_form_utils__ = __webpack_require__(363);
function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var ShippingEstimator=function(){function ShippingEstimator($element){_classCallCheck(this,ShippingEstimator);this.$element=$element;this.$state=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-field-type="State"]',this.$element);this.initFormValidation();this.bindStateCountryChange();this.bindEstimatorEvents()}ShippingEstimator.prototype.initFormValidation=function initFormValidation(){var _this=this;this.shippingEstimator='form[data-shipping-estimator]';this.shippingValidator=__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_nod__["a" /* default */])({submit:this.shippingEstimator+' .shipping-estimate-submit'});__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-submit',this.$element).click(function(event){// When switching between countries, the state/region is dynamic
// Only perform a check for all fields when country has a value
// Otherwise areAll('valid') will check country for validity
if(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(_this.shippingEstimator+' select[name="shipping-country"]').val()){_this.shippingValidator.performCheck()}if(_this.shippingValidator.areAll('valid')){return}event.preventDefault()});this.bindValidation();this.bindStateValidation();this.bindUPSRates()};ShippingEstimator.prototype.bindValidation=function bindValidation(){this.shippingValidator.add([{selector:this.shippingEstimator+' select[name="shipping-country"]',validate:function validate(cb,val){var countryId=Number(val);var result=countryId!==0&&!isNaN(countryId);cb(result)},errorMessage:'The \'Country\' field cannot be blank.'}])};ShippingEstimator.prototype.bindStateValidation=function bindStateValidation(){var _this2=this;this.shippingValidator.add([{selector:__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.shippingEstimator+' select[name="shipping-state"]'),validate:function validate(cb){var result=void 0;var $ele=__WEBPACK_IMPORTED_MODULE_0_jquery___default()(_this2.shippingEstimator+' select[name="shipping-state"]');if($ele.length){var eleVal=$ele.val();result=eleVal&&eleVal.length&&eleVal!=='State/province'}cb(result)},errorMessage:'The \'State/Province\' field cannot be blank.'}])};/**
     * Toggle between default shipping and ups shipping rates
     */ShippingEstimator.prototype.bindUPSRates=function bindUPSRates(){var UPSRateToggle='.estimator-form-toggleUPSRate';__WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').on('click',UPSRateToggle,function(event){var $estimatorFormUps=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.estimator-form--ups');var $estimatorFormDefault=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.estimator-form--default');event.preventDefault();$estimatorFormUps.toggleClass('u-hiddenVisually');$estimatorFormDefault.toggleClass('u-hiddenVisually')})};ShippingEstimator.prototype.bindStateCountryChange=function bindStateCountryChange(){var _this3=this;var $last=void 0;// Requests the states for a country with AJAX
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_state_country__["a" /* default */])(this.$state,this.context,{useIdForStates:true},function(err,field){if(err){alert(err);throw new Error(err)}var $field=__WEBPACK_IMPORTED_MODULE_0_jquery___default()(field);if(_this3.shippingValidator.getStatus(_this3.$state)!=='undefined'){_this3.shippingValidator.remove(_this3.$state)}if($last){_this3.shippingValidator.remove($last)}if($field.is('select')){$last=field;_this3.bindStateValidation()}else{$field.attr('placeholder','State/province');__WEBPACK_IMPORTED_MODULE_4__common_form_utils__["a" /* Validators */].cleanUpStateValidation(field)}// When you change a country, you swap the state/province between an input and a select dropdown
// Not all countries require the province to be filled
// We have to remove this class when we swap since nod validation doesn't cleanup for us
__WEBPACK_IMPORTED_MODULE_0_jquery___default()(_this3.shippingEstimator).find('.form-field--success').removeClass('form-field--success')})};ShippingEstimator.prototype.bindEstimatorEvents=function bindEstimatorEvents(){var $estimatorContainer=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimator');var $estimatorForm=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.estimator-form');$estimatorForm.on('submit',function(event){var params={country_id:__WEBPACK_IMPORTED_MODULE_0_jquery___default()('[name="shipping-country"]',$estimatorForm).val(),state_id:__WEBPACK_IMPORTED_MODULE_0_jquery___default()('[name="shipping-state"]',$estimatorForm).val(),city:__WEBPACK_IMPORTED_MODULE_0_jquery___default()('[name="shipping-city"]',$estimatorForm).val(),zip_code:__WEBPACK_IMPORTED_MODULE_0_jquery___default()('[name="shipping-zip"]',$estimatorForm).val()};event.preventDefault();__WEBPACK_IMPORTED_MODULE_3__bigcommerce_stencil_utils__["c" /* default */].api.cart.getShippingQuotes(params,'cart/shipping-quotes',function(err,response){__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-quotes').html(response.content);// bind the select button
__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.select-shipping-quote').on('click',function(clickEvent){var quoteId=__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-quote:checked').val();clickEvent.preventDefault();__WEBPACK_IMPORTED_MODULE_3__bigcommerce_stencil_utils__["c" /* default */].api.cart.submitShippingQuote(quoteId,function(){location.reload()})})})});__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-show').on('click',function(event){event.preventDefault();__WEBPACK_IMPORTED_MODULE_0_jquery___default()(event.currentTarget).hide();$estimatorContainer.removeClass('u-hiddenVisually');__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-hide').show()});__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-hide').on('click',function(event){event.preventDefault();$estimatorContainer.addClass('u-hiddenVisually');__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-show').show();__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.shipping-estimate-hide').hide()})};return ShippingEstimator}();/* harmony default export */ __webpack_exports__["a"] = (ShippingEstimator);

/***/ }),

/***/ 417:
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(402),
    LodashWrapper = __webpack_require__(406),
    baseLodash = __webpack_require__(403),
    isArray = __webpack_require__(15),
    isObjectLike = __webpack_require__(31),
    wrapperClone = __webpack_require__(428);

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit chaining.
 * Methods that operate on and return arrays, collections, and functions can
 * be chained together. Methods that retrieve a single value or may return a
 * primitive value will automatically end the chain returning the unwrapped
 * value. Explicit chaining may be enabled using `_.chain`. The execution of
 * chained methods is lazy, that is, execution is deferred until `_#value`
 * is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
 * fusion is an optimization strategy which merge iteratee calls; this can help
 * to avoid the creation of intermediate data structures and greatly reduce the
 * number of iteratee executions.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
 * `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
 * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
 * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
 * and `where`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
 * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
 * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
 * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
 * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
 * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
 * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
 * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
 * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
 * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
 * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
 * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
 * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
 * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
 * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
 * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
 * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
 * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
 * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
 * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
 * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
 * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
 * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
 * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
 * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
 * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
 * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
 * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
 * `unescape`, `uniqueId`, `value`, and `words`
 *
 * The wrapper method `sample` will return a wrapped value when `n` is provided,
 * otherwise an unwrapped value is returned.
 *
 * @name _
 * @constructor
 * @category Chain
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // returns an unwrapped value
 * wrapped.reduce(function(total, n) {
 *   return total + n;
 * });
 * // => 6
 *
 * // returns a wrapped value
 * var squares = wrapped.map(function(n) {
 *   return n * n;
 * });
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;

module.exports = lodash;


/***/ }),

/***/ 418:
/***/ (function(module, exports, __webpack_require__) {

var createWrapper = __webpack_require__(422),
    replaceHolders = __webpack_require__(405),
    restParam = __webpack_require__(239);

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    PARTIAL_FLAG = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and prepends any additional `_.bind` arguments to those provided to the
 * bound function.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind` this method does not set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * var greet = function(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * };
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // using placeholders
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = restParam(function(func, thisArg, partials) {
  var bitmask = BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, bind.placeholder);
    bitmask |= PARTIAL_FLAG;
  }
  return createWrapper(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

module.exports = bind;


/***/ }),

/***/ 419:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var createCtorWrapper = __webpack_require__(404);

/**
 * Creates a function that wraps `func` and invokes it with the `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new bound function.
 */
function createBindWrapper(func, thisArg) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
    return fn.apply(thisArg, arguments);
  }
  return wrapper;
}

module.exports = createBindWrapper;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),

/***/ 420:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var arrayCopy = __webpack_require__(242),
    composeArgs = __webpack_require__(408),
    composeArgsRight = __webpack_require__(409),
    createCtorWrapper = __webpack_require__(404),
    isLaziable = __webpack_require__(424),
    reorder = __webpack_require__(427),
    replaceHolders = __webpack_require__(405),
    setData = __webpack_require__(412);

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64,
    ARY_FLAG = 128;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that wraps `func` and invokes it with optional `this`
 * binding of, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to reference.
 * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurry = bitmask & CURRY_FLAG,
      isCurryBound = bitmask & CURRY_BOUND_FLAG,
      isCurryRight = bitmask & CURRY_RIGHT_FLAG,
      Ctor = isBindKey ? undefined : createCtorWrapper(func);

  function wrapper() {
    // Avoid `arguments` object use disqualifying optimizations by
    // converting it to an array before providing it to other functions.
    var length = arguments.length,
        index = length,
        args = Array(length);

    while (index--) {
      args[index] = arguments[index];
    }
    if (partials) {
      args = composeArgs(args, partials, holders);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight);
    }
    if (isCurry || isCurryRight) {
      var placeholder = wrapper.placeholder,
          argsHolders = replaceHolders(args, placeholder);

      length -= argsHolders.length;
      if (length < arity) {
        var newArgPos = argPos ? arrayCopy(argPos) : undefined,
            newArity = nativeMax(arity - length, 0),
            newsHolders = isCurry ? argsHolders : undefined,
            newHoldersRight = isCurry ? undefined : argsHolders,
            newPartials = isCurry ? args : undefined,
            newPartialsRight = isCurry ? undefined : args;

        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

        if (!isCurryBound) {
          bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
        }
        var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
            result = createHybridWrapper.apply(undefined, newData);

        if (isLaziable(func)) {
          setData(result, newData);
        }
        result.placeholder = placeholder;
        return result;
      }
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    if (argPos) {
      args = reorder(args, argPos);
    }
    if (isAry && ary < args.length) {
      args.length = ary;
    }
    if (this && this !== global && this instanceof wrapper) {
      fn = Ctor || createCtorWrapper(func);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybridWrapper;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),

/***/ 421:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var createCtorWrapper = __webpack_require__(404);

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` and invokes it with the optional `this`
 * binding of `thisArg` and the `partials` prepended to those provided to
 * the wrapper.
 *
 * @private
 * @param {Function} func The function to partially apply arguments to.
 * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to the new function.
 * @returns {Function} Returns the new bound function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    // Avoid `arguments` object use disqualifying optimizations by
    // converting it to an array before providing it `func`.
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength);

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartialWrapper;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(54)))

/***/ }),

/***/ 422:
/***/ (function(module, exports, __webpack_require__) {

var baseSetData = __webpack_require__(407),
    createBindWrapper = __webpack_require__(419),
    createHybridWrapper = __webpack_require__(420),
    createPartialWrapper = __webpack_require__(421),
    getData = __webpack_require__(410),
    mergeData = __webpack_require__(425),
    setData = __webpack_require__(412);

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to reference.
 * @param {number} bitmask The bitmask of flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  length -= (holders ? holders.length : 0);
  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func),
      newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

  if (data) {
    mergeData(newData, data);
    bitmask = newData[1];
    arity = newData[9];
  }
  newData[9] = arity == null
    ? (isBindKey ? 0 : func.length)
    : (nativeMax(arity - length, 0) || 0);

  if (bitmask == BIND_FLAG) {
    var result = createBindWrapper(newData[0], newData[2]);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
    result = createPartialWrapper.apply(undefined, newData);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setter(result, newData);
}

module.exports = createWrapper;


/***/ }),

/***/ 423:
/***/ (function(module, exports, __webpack_require__) {

var realNames = __webpack_require__(426);

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = array ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

module.exports = getFuncName;


/***/ }),

/***/ 424:
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(402),
    getData = __webpack_require__(410),
    getFuncName = __webpack_require__(423),
    lodash = __webpack_require__(417);

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

module.exports = isLaziable;


/***/ }),

/***/ 425:
/***/ (function(module, exports, __webpack_require__) {

var arrayCopy = __webpack_require__(242),
    composeArgs = __webpack_require__(408),
    composeArgsRight = __webpack_require__(409),
    replaceHolders = __webpack_require__(405);

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    ARY_FLAG = 128,
    REARG_FLAG = 256;

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers required to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
 * augment function arguments, making the order in which they are executed important,
 * preventing the merging of metadata. However, we make an exception for a safe
 * common case where curried functions have `_.ary` and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < ARY_FLAG;

  var isCombo =
    (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
    (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
    (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = arrayCopy(value);
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;


/***/ }),

/***/ 426:
/***/ (function(module, exports) {

/** Used to lookup unminified function names. */
var realNames = {};

module.exports = realNames;


/***/ }),

/***/ 427:
/***/ (function(module, exports, __webpack_require__) {

var arrayCopy = __webpack_require__(242),
    isIndex = __webpack_require__(69);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = arrayCopy(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;


/***/ }),

/***/ 428:
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(402),
    LodashWrapper = __webpack_require__(406),
    arrayCopy = __webpack_require__(242);

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  return wrapper instanceof LazyWrapper
    ? wrapper.clone()
    : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
}

module.exports = wrapperClone;


/***/ }),

/***/ 429:
/***/ (function(module, exports) {

/**
 * A no-operation function that returns `undefined` regardless of the
 * arguments it receives.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.noop(object) === undefined;
 * // => true
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ })

});
//# sourceMappingURL=theme-bundle.chunk.5.js.map