{"version":3,"sources":["webpack:///./assets/js/theme/common/nod.js?edc7","webpack:///./assets/js/theme/common/nod-functions/min-max-validate.js?fb2f","webpack:///./~/lodash/lang/isNaN.js?205a","webpack:///./~/nod-validate/nod.js?5fa7","webpack:///./assets/js/theme/wishlist.js"],"names":["nod","classes","errorClass","successClass","errorMessageClass","checkFunctions","minMaxValidate","minInputSelector","maxInputSelector","validate","cb","minValue","parseFloat","$","val","maxValue","WishList","options","template","wishlistDeleteConfirm","on","event","confirmed","confirm","context","wishlistDelete","preventDefault","registerAddWishListValidation","$addWishlistForm","addWishlistValidator","submit","add","selector","result","length","errorMessage","performCheck","areAll","wishListHandler","wishListUrl","currentTarget","href","modal","defaultModal","open","api","getPage","err","content","updateContent","wrap","$wishlistForm","$content","loaded","next","$addWishListForm"],"mappings":";;;;;;;;;AAGA;AACA,oDAAAA,CAAIC,OAAJ,CAAYC,UAAZ,CAAyB,mBAAzB,CACA,oDAAAF,CAAIC,OAAJ,CAAYE,YAAZ,CAA2B,qBAA3B,CACA,oDAAAH,CAAIC,OAAJ,CAAYG,iBAAZ,CAAgC,oBAAhC,CAEA;AACA,oDAAAJ,CAAIK,cAAJ,CAAmB,SAAnB,EAAgC,gFAAhC,CAEA,yDAAe,oDAAf,E;;;;;;;;;;;;ACRA,QAASC,eAAT,CAAwBC,gBAAxB,CAA0CC,gBAA1C,CAA4D,CACxD,QAASC,SAAT,CAAkBC,EAAlB,CAAsB,CAClB,GAAMC,UAAWC,WAAW,8CAAAC,CAAEN,gBAAF,EAAoBO,GAApB,EAAX,CAAjB,CACA,GAAMC,UAAWH,WAAW,8CAAAC,CAAEL,gBAAF,EAAoBM,GAApB,EAAX,CAAjB,CAEA,GAAIC,SAAWJ,QAAX,EAAuB,0DAAQI,QAAR,CAAvB,EAA4C,0DAAQJ,QAAR,CAAhD,CAAmE,CAC/D,MAAOD,IAAG,IAAH,CACV,CAED,MAAOA,IAAG,KAAH,CACV,CAED,MAAOD,SACV,CAED,yDAAeH,cAAf,E;;;;;;;AClBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA,uDAAuD,SAAS;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C,2CAA2C;AAC3C,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D,gBAAgB;;AAE7E;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;8yBC3sCqBU,S,yDACjB,mBAAc,0EACV,uBADU,EAGV,MAAKC,OAAL,CAAe,CACXC,SAAU,sBADC,CAAf,CAHU,YAMb,CAED;;0BAGAC,qB,iCAAwB,iBACpB,8CAAAN,CAAE,MAAF,EAAUO,EAAV,CAAa,OAAb,CAAsB,wBAAtB,CAAgD,SAACC,KAAD,CAAW,CACvD,GAAMC,WAAYC,QAAQ,OAAKC,OAAL,CAAaC,cAArB,CAAlB,CAEA,GAAIH,SAAJ,CAAe,CACX,MAAO,KACV,CAEDD,MAAMK,cAAN,EACH,CARD,CASH,C,oBAEDC,6B,wCAA8BC,gB,CAAkB,iBAC5C,KAAKC,oBAAL,CAA4B,mFAAA7B,CAAI,CAC5B8B,OAAQ,qCADoB,CAAJ,CAA5B,CAIA,KAAKD,oBAAL,CAA0BE,GAA1B,CAA8B,CAC1B,CACIC,SAAU,2CADd,CAEIvB,SAAU,kBAACC,EAAD,CAAKI,GAAL,CAAa,CACnB,GAAMmB,QAASnB,IAAIoB,MAAJ,CAAa,CAA5B,CAEAxB,GAAGuB,MAAH,CACH,CANL,CAOIE,aAAc,iCAPlB,CAD0B,CAA9B,EAYAP,iBAAiBE,MAAjB,CAAwB,SAACT,KAAD,CAAW,CAC/B,OAAKQ,oBAAL,CAA0BO,YAA1B,GAEA,GAAI,OAAKP,oBAAL,CAA0BQ,MAA1B,CAAiC,OAAjC,CAAJ,CAA+C,CAC3C,MACH,CAEDhB,MAAMK,cAAN,EACH,CARD,CASH,C,oBAEDY,e,2BAAkB,iBACd,8CAAAzB,CAAE,MAAF,EAAUO,EAAV,CAAa,OAAb,CAAsB,iBAAtB,CAAyC,SAACC,KAAD,CAAW,CAChD,GAAMkB,aAAclB,MAAMmB,aAAN,CAAoBC,IAAxC,CACA,GAAMC,OAAQ,0FAAAC,EAAd,CAEAtB,MAAMK,cAAN,GAEAgB,MAAME,IAAN,GAEA,uEAAAC,CAAIC,OAAJ,CAAYP,WAAZ,CAAyB,OAAKtB,OAA9B,CAAuC,SAAC8B,GAAD,CAAMC,OAAN,CAAkB,CACrD,GAAID,GAAJ,CAAS,CACL,MAAOL,OAAMO,aAAN,CAAoBF,GAApB,CACV,CAEDL,MAAMO,aAAN,CAAoBD,OAApB,CAA6B,CAAEE,KAAM,IAAR,CAA7B,EAEA,GAAMC,eAAgB,8CAAAtC,CAAE,gBAAF,CAAoB6B,MAAMU,QAA1B,CAAtB,CAEA,OAAKzB,6BAAL,CAAmCwB,aAAnC,CACH,CAVD,CAWH,CAnBD,CAoBH,C,oBAEDE,M,iBAAOC,I,CAAM,CACT,GAAMC,kBAAmB,8CAAA1C,CAAE,gBAAF,CAAzB,CAEA,GAAI0C,iBAAiBrB,MAArB,CAA6B,CACzB,KAAKP,6BAAL,CAAmC4B,gBAAnC,CACH,CAED,KAAKpC,qBAAL,GACA,KAAKmB,eAAL,GAEAgB,MACH,C,kBAtFiC,8D,iEAAjBtC,Q","file":"theme-bundle.chunk.1.js","sourcesContent":["import nod from 'nod-validate';\nimport minMaxValidate from './nod-functions/min-max-validate';\n\n// Hook our SCSS framework form field status classes into the nod validation system before use\nnod.classes.errorClass = 'form-field--error';\nnod.classes.successClass = 'form-field--success';\nnod.classes.errorMessageClass = 'form-inlineMessage';\n\n// Register validate functions\nnod.checkFunctions['min-max'] = minMaxValidate;\n\nexport default nod;\n\n\n\n// WEBPACK FOOTER //\n// ./assets/js/theme/common/nod.js","import _ from 'lodash';\nimport $ from 'jquery';\n\nfunction minMaxValidate(minInputSelector, maxInputSelector) {\n    function validate(cb) {\n        const minValue = parseFloat($(minInputSelector).val());\n        const maxValue = parseFloat($(maxInputSelector).val());\n\n        if (maxValue > minValue || _.isNaN(maxValue) || _.isNaN(minValue)) {\n            return cb(true);\n        }\n\n        return cb(false);\n    }\n\n    return validate;\n}\n\nexport default minMaxValidate;\n\n\n\n// WEBPACK FOOTER //\n// ./assets/js/theme/common/nod-functions/min-max-validate.js","var isNumber = require('./isNumber');\n\n/**\n * Checks if `value` is `NaN`.\n *\n * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n * which returns `true` for `undefined` and other non-numeric values.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n * @example\n *\n * _.isNaN(NaN);\n * // => true\n *\n * _.isNaN(new Number(NaN));\n * // => true\n *\n * isNaN(undefined);\n * // => true\n *\n * _.isNaN(undefined);\n * // => false\n */\nfunction isNaN(value) {\n  // An `NaN` primitive is the only value that is not equal to itself.\n  // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n  return isNumber(value) && value != +value;\n}\n\nmodule.exports = isNaN;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/lang/isNaN.js\n// module id = 361\n// module chunks = 0 1 2 3 5 6 7 8 9 10","\n/**\n *\n *\n * nod v.2.0.12\n * Gorm Casper\n *\n *\n *\n * This is a short breakdown of the code to help you find your way around.\n *\n *\n * An `element` always refer to some input element defined by the user via the\n * `selector` key.\n *\n * A `metric` is the user created objects that is used to add checks to\n * nod.\n *\n * Each `element` will have at most one of a `listener`, a `checker`, a\n * `checkHandler`, and a `domNode` \"attached\" to it. The `listener` listens\n * for inputs or changes to the `element` and passes the new value on to to the\n * `checker` which performs its checks and passes the the results on to the\n * `checkHandler` which calculates the new state of the `element` which it\n * passes on to the `domNode` which will update the dom.\n *\n * The four main parts, the listener, the checker, the checkHandler, and the\n * domNode all communicate through the `mediator` by firing events identified\n * by a unique id. They do not know of each other's existance, and so no\n * communication flows directly between them.\n *\n * All listeners, checkers, handlers, and domNodes are grouped together in\n * `collections`, which are basically a glorified array that makes it easy\n * not to get duplicate items for each element (for instance two listeners\n * listening to the same element).\n *\n * The communication flow looks like this:\n * listener -> checker -> checkHandler -> domNode\n *\n * Between each part, you have the mediator.\n *\n *\n * `Metrics` are added by the user, which sets up the system above. Notice\n * that a metric can target multiple elements at once, and that there can\n * be overlaps. One metric definitely does not equal one element or one\n * check.\n *\n */\n\nfunction nod (config) {\n    var form,\n        configuration   = {},\n        mediator        = nod.makeMediator(),\n        eventEmitter    = nod.makeEventEmitter(mediator),\n\n        // Creating (empty) collections\n        listeners       = nod.makeCollection(nod.makeListener),\n        checkers        = nod.makeCollection(nod.makeChecker),\n        checkHandlers   = nod.makeCollection(nod.makeCheckHandler),\n        domNodes        = nod.makeCollection(nod.makeDomNode);\n\n    /**\n     * Entry point for the user. The user passes in an array of metrics (an\n     * object containing a selector, a validate string/function, etc.) and it\n     * gets processed from here.\n     *\n     * This function, is mostly about cleaning up what the user passed us.\n     */\n    function addMetrics (metrics) {\n        // Make sure we are dealing with an array of metrics.\n        var arrayMetrics = Array.isArray(metrics) ? metrics : [metrics];\n\n        arrayMetrics.forEach(function (metric) {\n            var validateArray, errorMessageArray,\n                notArray = !Array.isArray(metric.validate);\n\n            // If the 'validate' is not an array, then we're good to go.\n            if (notArray) {\n                addMetric(metric);\n\n            // If it is an array (e.g., validate: ['email', 'max-length:10']),\n            // then we need to split them up into multiple metrics, and add\n            // them individually.\n            } else {\n                if (!Array.isArray(metric.errorMessage)) {\n                    var errorMsg = 'If you pass in `validate:...` as an ' +\n                        ' array, then `errorMessage:...` also needs to be an ' +\n                        ' array. \"' + metric.validate + '\", and \"' +\n                        metric.errorMessage + '\"';\n\n                    throw Error(errorMsg);\n                }\n\n                // We store each as arrays, and then run through them,\n                // overwriting each of the keys accordingly.\n                validateArray     = metric.validate;\n                errorMessageArray = metric.errorMessage;\n\n                validateArray.forEach(function (validate, i) {\n                    // Overwrite the array with the individual 'validate' and\n                    // 'errorMessage'.\n                    metric.validate     = validate;\n                    metric.errorMessage = errorMessageArray[i];\n\n                    addMetric(metric);\n                });\n            }\n        });\n    }\n\n    function addMetric (metric) {\n        var specialTriggers = [],\n\n            // The function that will check the value of the element.\n            checkFunction = nod.getCheckFunction(metric),\n\n            // A list of elements that this metric will target.\n            elements = nod.getElements(metric.selector),\n\n            // A \"set\" here, refers to an obj with one listener, one checker,\n            // and one checkHandler. Only every one for each element in the\n            // dom.\n            metricSets = elements.map(function (element) {\n                return {\n                    listener:       listeners.findOrMake(element,\n                                                         mediator,\n                                                         metric.triggerEvents,\n                                                         configuration),\n                    checker:        checkers.findOrMake(element, mediator),\n                    checkHandler:   checkHandlers.findOrMake(element,\n                                                             mediator,\n                                                             configuration),\n                    domNode:        domNodes.findOrMake(element,\n                                                        mediator,\n                                                        configuration)\n                };\n            });\n\n        // Saved for later reference in case the user has a `tap` function\n        // defined.\n        checkFunction.validate = (typeof metric.validate === 'function')\n            ? metric.validate.toString()\n            : metric.validate;\n\n        // Special cases. These `validates` affect each other, and their state\n        // needs to update each time either of the elements' values change.\n        if (metric.validate === 'one-of'\n            || metric.validate === 'only-one-of'\n            || metric.validate === 'some-radio') {\n            specialTriggers.push(metric.selector);\n        }\n\n        if (typeof metric.validate === 'string'\n            && metric.validate.indexOf('same-as') > -1) {\n            specialTriggers.push(metric.validate.split(':')[1]);\n        }\n\n        // Helper function, used in the loop below.\n        function subscribeToTriggers (checker, selector) {\n            var triggerElements = nod.getElements(selector);\n\n            triggerElements.forEach(function (element) {\n                var listener = listeners.findOrMake(element,\n                                                    mediator,\n                                                    null,\n                                                    configuration);\n\n                checker.subscribeTo(listener.id);\n            });\n        }\n\n        // Here we set up the \"connections\" between each of our main parts.\n        // They communicate only through the mediator.\n        metricSets.forEach(function (metricSet) {\n            // :: Listener -> Checker\n\n            // We want our checker to listen to the listener. A listener has an\n            // id, which it uses when it fires events to the mediator (which\n            // was set up when the listener was created).\n            metricSet.checker.subscribeTo(metricSet.listener.id);\n\n            // If the user set a `triggeredBy`, the checker need to listen to\n            // changes on this element as well.\n            // Same goes for special triggers that we set.\n            subscribeToTriggers(metricSet.checker, metric.triggeredBy);\n            subscribeToTriggers(metricSet.checker, specialTriggers);\n\n            // :: Checker -> checkHandler\n\n            var checkId = nod.unique();\n\n            // We add the check function as one to be checked when the user\n            // inputs something. (There might be more than this one).\n            metricSet.checker.addCheck(checkFunction, checkId);\n\n            // We want the check handler to listen for results from the checker\n            metricSet.checkHandler.subscribeTo(checkId,\n                                               metric.errorMessage,\n                                               metric.defaultStatus);\n\n            if (configuration.noDom) {\n                eventEmitter.subscribe(metricSet.checkHandler.id);\n            } else {\n                // :: checkHandler -> domNode\n\n                // The checkHandler has its own id (and only ever needs one), so\n                // we just ask the domNode to listen for that.\n                metricSet.domNode.subscribeTo(metricSet.checkHandler.id);\n            }\n        });\n\n        // After all is done, we may have to enable/disable a submit button.\n        toggleSubmit();\n    }\n\n    /**\n     * If a form is added, we listen for submits, and if the has also set\n     * `preventSubmit` in the configuration, then we stop the commit from\n     * happening unless all the elements are valid.\n     */\n    function addForm (selector) {\n        var form = nod.getElement(selector);\n\n        form.addEventListener('submit', possiblePreventSubmit, false);\n    }\n\n    // Prevent function, used above\n    function possiblePreventSubmit (event) {\n        if (configuration.preventSubmit && !areAll(nod.constants.VALID)) {\n            event.preventDefault();\n\n            // Show errors to the user\n            checkers.forEach(function (checker) {\n                checker.performCheck({\n                    event: event\n                });\n            });\n\n            // Focus on the first invalid element\n            for (var i = 0, len = checkHandlers.length; i < len; i++) {\n                var checkHandler = checkHandlers[i];\n\n                if (checkHandler.getStatus().status === nod.constants.INVALID) {\n                    checkHandler.element.focus();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes elements completely.\n     */\n    function removeElement (selector) {\n        var elements = nod.getElements(selector);\n\n        elements.forEach(function (element) {\n            listeners.removeItem(element);\n            checkers.removeItem(element);\n            checkHandlers.removeItem(element);\n            domNodes.removeItem(element);\n        });\n    }\n\n    /**\n     * configure\n     *\n     * Changes the configuration object used throughout the code for classes,\n     * delays, messages, etc.\n     *\n     * It can either be called with a key/value pair (two arguments), or with\n     * an object with key/value pairs.\n     */\n    function configure (key, value) {\n        var attributes = {};\n\n        if (arguments.length > 1) {\n            attributes[key] = value;\n        } else {\n            attributes = key;\n        }\n\n        for (var k in attributes) {\n            configuration[k] = attributes[k];\n        }\n\n        if (attributes.submit || attributes.disableSubmit) {\n            toggleSubmit();\n        }\n\n        if (attributes.form) {\n            addForm(attributes.form);\n        }\n    }\n\n    /**\n     * toggleSubmit\n     *\n     * Toggles the submit button (enabled if every element is valid, otherwise\n     * disabled).\n     */\n    function toggleSubmit () {\n        if (configuration.submit && configuration.disableSubmit) {\n            nod.getElements(configuration.submit).forEach(function (submitBtn) {\n                submitBtn.disabled = !areAll(nod.constants.VALID);\n            });\n        }\n    }\n\n    /**\n     * Listen to all checks, and if the user has set in the configuration to\n     * enable/disabled the submit button, we do that.\n     */\n    mediator.subscribe('all', toggleSubmit);\n\n    function areAll (status) {\n        for (var i = 0, len = checkHandlers.length; i < len; i++) {\n            if (checkHandlers[i].getStatus().status !== status) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setMessageOptions (options) {\n        options = Array.isArray(options) ? options : [options];\n\n        options.forEach(function (option) {\n            var elements = nod.getElements(option.selector);\n\n            elements.forEach(function (element) {\n                var domNode = domNodes.findOrMake(element,\n                                                  mediator,\n                                                  configuration);\n\n                domNode.setMessageOptions(option.parent, option.errorSpan);\n            });\n        });\n    }\n\n    /**\n     * Listen to all checks and allow the user to listen in, if he set a `tap`\n     * function in the configuration.\n     */\n    mediator.subscribe('all', function (options) {\n        if (typeof configuration.tap === 'function'\n            && options.type === 'check') {\n            configuration.tap(options);\n        }\n    });\n\n    function getStatus (selector, showErrorMessage) {\n        var element = nod.getElement(selector),\n            status  = checkHandlers.findOrMake(element).getStatus();\n\n        return showErrorMessage ? status : status.status;\n    }\n\n    function performCheck (selector) {\n        var cs = selector\n            ? nod.getElements(selector).map(checkers.findOrMake)\n            : checkers;\n\n        cs.forEach(function (checker) {\n            checker.performCheck();\n        });\n    }\n\n    function setInvalid (selector, errorMessage) {\n        var element = nod.getElement(selector),\n            domNode  = domNodes.findOrMake(element);\n\n        domNode.set({\n            result: nod.constants.INVALID,\n            errorMessage: errorMessage || ''\n        });\n    }\n\n    function setValid (selector) {\n        var element = nod.getElement(selector),\n            domNode  = domNodes.findOrMake(element);\n\n        domNode.set({\n            result: nod.constants.VALID,\n            errorMessage: ''\n        });\n    }\n\n    function setAllNodeValid () {\n        for (var i = 0, len = domNodes.length; i < len; i++) {\n            setValid(domNodes[i].element);\n        }\n    }\n\n    /**\n     * Internal functions that are exposed to the public.\n     */\n    var nodInstace = {\n        add:                    addMetrics,\n        remove:                 removeElement,\n        areAll:                 areAll,\n        getStatus:              getStatus,\n        configure:              configure,\n        setMessageOptions:      setMessageOptions,\n        performCheck:           performCheck,\n        setInvalid:             setInvalid,\n        setValid:               setValid,\n        setAllNodeValid:        setAllNodeValid\n    };\n\n    if (config) {\n        nodInstace.configure(config);\n    }\n\n    return nodInstace;\n}\n\nnod.constants = {\n    VALID:          'valid',\n    INVALID:        'invalid',\n    UNCHECKED:      'unchecked',\n\n    DELAY:          700\n};\n\nnod.classes = {\n    successClass:         'nod-success',\n    successMessageClass:  'nod-success-message',\n    errorClass:           'nod-error',\n    errorMessageClass:    'nod-error-message'\n};\n\n// Helper function to create unique id's\nnod.unique = (function () {\n    var uniqueCounter = 0;\n\n    return function () {\n        return uniqueCounter++;\n    };\n})();\n\n/** makeMediator\n *\n * Minimal implementation of a mediator pattern, used for communication between\n * checkers and checkHandlers (checkers fires events which handlers can\n * subscribe to). Unique ID's are used to tell events apart.\n *\n * Subscribing to 'all' will give you all results from all checks.\n */\nnod.makeMediator = function () {\n    var subscribers = [],\n        all = [];\n\n    return {\n        subscribe: function subscribe (id, fn) {\n            if (id === 'all') {\n                all.push(fn);\n            } else {\n                if (!subscribers[id]) {\n                    subscribers[id] = [];\n                }\n\n                if (subscribers[id].indexOf(fn) === -1) {\n                    subscribers[id].push(fn);\n                }\n            }\n        },\n\n        fire: function fire (options) {\n            var subscribedFunctions = subscribers[options.id].concat(all);\n\n            subscribedFunctions.forEach(function (subscribedFunction) {\n                subscribedFunction(options);\n            });\n        }\n    };\n};\n\nnod.findCollectionIndex = function (collection, element) {\n    for (var i in collection) {\n        if (collection[i].element === element) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n/**\n * makeCollection\n *\n * A minimal implementation of a \"collection\", inspired by collections from\n * BackboneJS. Used by listeners, checkers, and checkHandlers.\n */\nnod.makeCollection = function (maker) {\n    var collection = [];\n\n    collection.findOrMake = function (element) {\n        var index = nod.findCollectionIndex(collection, element);\n\n        // Found\n        if (index !== -1) {\n            return collection[index];\n        }\n\n        // None found, let's make one then.\n        var item = maker.apply(null, arguments);\n\n        collection.push(item);\n\n        return item;\n    };\n\n    collection.removeItem = function (element) {\n        var index = nod.findCollectionIndex(collection, element),\n            item = collection[index];\n\n        if (!item) {\n            return;\n        }\n\n        // Call .dispose() if it exists\n        if (typeof item.dispose === 'function') {\n            item.dispose();\n        }\n\n        // Remove item\n        collection.splice(index, 1);\n    };\n\n    return collection;\n};\n\n/**\n * makeListener\n *\n * Takes care of listening to changes to its element and fire them off as\n * events on the mediator for checkers to listen to.\n */\nnod.makeListener = function (element, mediator, triggerEvents, configuration) {\n    var id = nod.unique(),\n        $element;\n\n    function changed (event) {\n        mediator.fire({\n            id:     id,\n            event:  event,\n            type:   'change'\n        });\n    }\n\n    element.addEventListener('input', changed, false);\n    element.addEventListener('change', changed, false);\n    element.addEventListener('blur', changed, false);\n\n    if (configuration.jQuery) {\n        $element = configuration.jQuery(element);\n\n        $element.on('propertychange change click keyup input paste', changed);\n    }\n\n    if (triggerEvents) {\n        triggerEvents = Array.isArray(triggerEvents)\n            ? triggerEvents\n            : [triggerEvents];\n\n        triggerEvents.forEach(function (eventName) {\n            element.addEventListener(eventName, changed, false);\n        });\n    }\n\n    function dispose () {\n        element.removeEventListener('input', changed, false);\n        element.removeEventListener('change', changed, false);\n        element.removeEventListener('blur', changed, false);\n\n        if ($element) {\n            $element.off();\n        }\n\n        if (triggerEvents) {\n            triggerEvents.forEach(function (eventName) {\n                element.removeEventListener(eventName, changed, false);\n            });\n        }\n    }\n\n    return {\n        element:    element,\n        dispose:    dispose,\n        id:         id\n    };\n};\n\n/**\n * makeChecker\n *\n * An \"checker\" communicates primarily with the mediator. It listens for input\n * changes (coming from listeners), performs its checks and fires off results\n * back to the mediator for checkHandlers to handle.\n *\n * The checker has a 1 to 1 relationship with an element, an listeners, and an\n * checkHandler; although they may communicate with other \"sets\" of listeners,\n * checkers and handlers.\n *\n * Checks are added, from the outside, and consists of a checkFunction (see\n * nod.checkFunctions) and a unique id.\n */\nnod.makeChecker = function (element, mediator) {\n    var checks = [];\n\n    function subscribeTo (id) {\n        mediator.subscribe(id, performCheck);\n    }\n\n    // Run every check function against the value of the element.\n    function performCheck (options) {\n        checks.forEach(function (check) {\n            check(options || {});\n        });\n    }\n\n    // Add a check function to the element. The result will be handed off to the\n    // mediator (for checkHandlers to evaluate).\n    function addCheck (checkFunction, id) {\n        function callback (result) {\n            mediator.fire({\n                id: id,\n                type: 'check',\n                result: result,\n                element: element,\n                validate: checkFunction.validate\n            });\n        }\n\n        checks.push(function (options) {\n            // If element.value is undefined, then we might be dealing with\n            // another type of element; like <div contenteditable='true'>\n            var value = element.value === undefined\n                ? element.innerHTML\n                : element.value;\n\n            options.element = element;\n\n            checkFunction(callback, value, options);\n        });\n    }\n\n    return {\n        subscribeTo:    subscribeTo,\n        addCheck:       addCheck,\n        performCheck:   performCheck,\n        element:        element\n    };\n};\n\n/**\n * makeCheckHandler\n *\n * Handles checks coming in from the mediator and takes care of calculating the\n * state and error messages.\n *\n * The checkHandlers lives in one to one with the element parsed in, and listens\n * for (usually) multiple error checks.\n */\nnod.makeCheckHandler = function (element, mediator, configuration) {\n    var results     = {},\n        id          = nod.unique();\n\n    function subscribeTo (id, errorMessage, defaultStatus) {\n        // Create a representation of the type of error in the results object.\n        if (!results[id]) {\n            results[id] = {\n                status: defaultStatus || nod.constants.UNCHECKED,\n                errorMessage: errorMessage\n            };\n        }\n\n        // Subscribe to error id.\n        mediator.subscribe(id, checkHandler);\n    }\n\n    function checkHandler (result) {\n        results[result.id].status = result.result\n            ? nod.constants.VALID\n            : nod.constants.INVALID;\n\n        notifyMediator();\n    }\n\n    // Runs through all results to see what kind of feedback to show the user.\n    function notifyMediator () {\n        var status = getStatus();\n\n        // Event if might be valid we pass along an undefined errorMessage.\n        mediator.fire({\n            id:             id,\n            type:           'result',\n            result:         status.status,\n            element:        element,\n            errorMessage:   status.errorMessage\n        });\n    }\n\n    function getStatus () {\n        var status, errorMessage;\n\n        for (var id in results) {\n            status = results[id].status;\n\n            if (results[id].status === nod.constants.INVALID) {\n                errorMessage = results[id].errorMessage;\n                break;\n            }\n        }\n\n        return {\n            status:        status,\n            errorMessage:  errorMessage\n        };\n    }\n\n    return {\n        id:             id,\n        subscribeTo:    subscribeTo,\n        checkHandler:   checkHandler,\n        getStatus:      getStatus,\n        element:        element\n    };\n};\n\n// Helper functions for `makeDomNode`.\nnod.hasClass = function (className, el) {\n    if (el.classList) {\n        return el.classList.contains(className);\n    } else {\n        var regex = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n        return !!el.className.match(regex);\n    }\n};\n\nnod.removeClass = function (className, el) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else if (nod.hasClass(className, el)) {\n        var regex = new RegExp('(?:^|\\\\s)' + className + '(?!\\\\S)');\n        el.className = el.className.replace(regex, '');\n    }\n};\n\nnod.addClass = function (className, el) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else if (!nod.hasClass(className, el)) {\n        el.className += ' ' + className;\n    }\n};\n\nnod.getParent = function (element, configuration) {\n    var klass = configuration.parentClass;\n\n    if (klass) {\n        klass = klass.charAt(0) === '.' ? klass.slice(1) : klass;\n        return nod.findParentWithClass(element.parentNode, klass);\n    } else {\n        return element.parentNode;\n    }\n};\n\nnod.findParentWithClass = function (parent, klass) {\n    // Guard (only the `window` does not have a parent).\n    if (!parent.parentNode) {\n        return parent;\n    }\n\n    // Found it\n    if (nod.hasClass(klass, parent)) {\n        return parent;\n    }\n\n    // Try next parent (recursion)\n    return nod.findParentWithClass(parent.parentNode, klass);\n};\n\n/**\n * makeDomNode\n *\n * This creates the error/success message behind the input element, as well as\n * takes care of updating classes and taking care of its own state.\n *\n * The dom node is owned by checkHandler, and has a one to one relationship with\n * both the checkHandler and the input element being checked.\n *\n */\nnod.makeDomNode = function (element, mediator, configuration) {\n    // A 'domNode' consists of two elements: a 'parent', and a 'span'. The\n    // parent is given as a paremeter, while the span is created and added as a\n    // child to the parent.\n    var parent              = nod.getParent(element, configuration),\n        _status             = nod.constants.UNCHECKED,\n        pendingUpdate       = null,\n        span                = document.createElement('span'),\n        customSpan          = false;\n\n    span.style.display = 'none';\n\n    if (!configuration.noDom) {\n        parent.appendChild(span);\n    }\n\n    // Updates the class of the parent to match the status of the element.\n    function updateParent (status) {\n        var successClass = configuration.successClass\n                           || nod.classes.successClass,\n            errorClass = configuration.errorClass\n                         || nod.classes.errorClass;\n\n        switch (status) {\n        case nod.constants.VALID:\n            nod.removeClass(errorClass, parent);\n            nod.addClass(successClass, parent);\n            break;\n\n        case nod.constants.INVALID:\n            nod.removeClass(successClass, parent);\n            nod.addClass(errorClass, parent);\n            break;\n        }\n    }\n\n    // Updates the text and class according to the status.\n    function updateSpan (status, errorMessage) {\n        var successMessageClass = configuration.successMessageClass\n                                  || nod.classes.successMessageClass,\n          errorMessageClass   = configuration.errorMessageClass\n                                || nod.classes.errorMessageClass;\n\n        span.style.display = 'none';\n\n        switch (status) {\n        case nod.constants.VALID:\n            nod.removeClass(errorMessageClass, span);\n            nod.addClass(successMessageClass, span);\n\n            if (configuration.successMessage) {\n                span.textContent = configuration.successMessage;\n                span.style.display = '';\n            }\n\n            break;\n\n        case nod.constants.INVALID:\n            nod.removeClass(successMessageClass, span);\n            nod.addClass(errorMessageClass, span);\n            span.textContent = errorMessage;\n            span.style.display = '';\n            break;\n        }\n    }\n\n    function set (options) {\n        var status              = options.result,\n            errorMessage        = options.errorMessage;\n\n        // If the dom is showing an invalid message, we want to update the dom\n        // right away.\n        if (_status === nod.constants.INVALID || configuration.delay === 0) {\n            _status = status;\n            updateParent(status);\n            updateSpan(status, errorMessage);\n        } else {\n            // If the dom shows either an unchecked or a valid state we won't\n            // rush to tell them they are wrong. Instead we use a method similar\n            // to \"debouncing\" the update\n            clearTimeout(pendingUpdate);\n\n            pendingUpdate = setTimeout(function () {\n                _status = status;\n                updateParent(status);\n                updateSpan(status, errorMessage);\n                pendingUpdate = null;\n            }, configuration.delay || nod.constants.DELAY);\n        }\n    }\n\n    function subscribeTo (id) {\n        mediator.subscribe(id, set);\n    }\n\n    function setMessageOptions (parentContainer, message) {\n        if (parentContainer) {\n            parent = nod.getElement(parentContainer);\n        }\n\n        if (message) {\n            span.parentNode.removeChild(span);      // Remove old span.\n            span = nod.getElement(message);         // Set the new one.\n            customSpan = true;                      // So we won't delete it.\n        }\n    }\n\n    function dispose () {\n        // First remove any classes\n        nod.removeClass(configuration.errorClass\n                        || nod.classes.errorClass, parent);\n        nod.removeClass(configuration.successClass\n                        || nod.classes.successClass, parent);\n\n        // Then we remove the span if it wasn't one that was set by the user.\n        // If `noDom` was used, then there won't be any to remove.\n        if (span.parentNode && !customSpan) {\n            span.parentNode.removeChild(span);\n        }\n    }\n\n    return {\n        subscribeTo:        subscribeTo,\n        element:            element,\n        setMessageOptions:  setMessageOptions,\n        dispose:            dispose,\n        set:                set\n    };\n};\n\nnod.makeEventEmitter = function (mediator) {\n    var customEvent;\n\n    function emit (options) {\n        if (CustomEvent) {\n            customEvent = new CustomEvent('nod.validation', {detail: options});\n\n            options.element.dispatchEvent(customEvent);\n        } else {\n            var errorMsg = 'nod.validate tried to fire a custom event, but ' +\n                           'the browser does not support CustomEvent\\'s';\n\n            throw Error(errorMsg);\n        }\n    }\n\n    function subscribe (id) {\n        mediator.subscribe(id, emit);\n    }\n\n    return {\n        subscribe: subscribe\n    };\n};\n\n/**\n * getElement\n *\n * Returns the first element targeted by the selector. (see `getElements`)\n */\nnod.getElement = function (selector) {\n    return nod.getElements(selector)[0];\n};\n\n/**\n * getElements\n *\n * Takes some sort of selector, and returns an array of element(s). The applied\n * selector can be one of:\n *\n * - Css type selector (e.g., \".foo\")\n * - A jQuery element (e.g., $('.foo))\n * - A single raw dom element (e.g., document.getElementById('foo'))\n * - A list of raw dom element (e.g., $('.foo').get())\n */\nnod.getElements = function (selector) {\n    if (!selector) {\n        return [];\n    }\n\n    // Normal css type selector is assumed\n    if (typeof selector === 'string') {\n        // If we have jQuery, then we use that to create a dom list for us.\n        if (window.jQuery) {\n            return window.jQuery(selector).get();\n        }\n\n        // If not, then we do it the manual way.\n        var nodeList = document.querySelectorAll(selector);\n\n        return [].map.call(nodeList, function (el) {\n            return el;\n        });\n    }\n\n    // if user gave us jQuery elements\n    if (selector.jquery) {\n        return selector.get();\n    }\n\n    // Raw DOM element\n    if (selector.nodeType === 1) {\n        return [selector];\n    }\n\n    if (Array.isArray(selector)) {\n        var result = [];\n\n        selector.forEach(function (sel) {\n            var elements = nod.getElements(sel);\n\n            result = result.concat(elements);\n        });\n\n        return result;\n    }\n\n    throw Error('Unknown type of elements in your `selector`: ' + selector);\n};\n\nnod.getCheckFunction = function (metric) {\n    if (typeof metric.validate === 'function') {\n        return metric.validate;\n    }\n\n    if (metric.validate instanceof RegExp) {\n        return nod.checkFunctions.regexp(metric.validate);\n    }\n\n    var args   = metric.validate.split(':'),\n        fnName = args.shift();\n\n    if (fnName === 'one-of' || fnName === 'only-one-of' ||\n        fnName === 'same-as' || fnName === 'some-radio') {\n        args.push(metric.selector);\n    }\n\n    if (typeof nod.checkFunctions[fnName] === 'function') {\n        return nod.checkFunctions[fnName].apply(null, args);\n    } else {\n        var errorMsg = 'Couldn\\'t find your validator function \"' +\n                       fnName + '\" for \"' + metric.selector + '\"';\n\n        throw Error(errorMsg);\n    }\n};\n\n// Collection of built-in check functions\nnod.checkFunctions = {\n    'presence': function () {\n        return function presence (callback, value) {\n            callback(value.length > 0);\n        };\n    },\n\n    'exact': function (exactValue) {\n        return function exact (callback, value) {\n            callback(value === exactValue);\n        };\n    },\n\n    'contains': function (containsValue) {\n        return function contains (callback, value) {\n            callback(value.indexOf(containsValue) > -1);\n        };\n    },\n\n    'not': function (exactValue) {\n        return function not (callback, value) {\n            callback(value !== exactValue);\n        };\n    },\n\n    'min-length': function (minimumLength) {\n        return function minLength (callback, value) {\n            callback(value.length >= minimumLength);\n        };\n    },\n\n    'max-length': function (maximumLength) {\n        return function maxLength (callback, value) {\n            callback(value.length <= maximumLength);\n        };\n    },\n\n    'exact-length': function (exactLen) {\n        return function exactLength (callback, value) {\n            callback(value.length === +exactLen);\n        };\n    },\n\n    'between-length': function (minimumLength, maximumLength) {\n        return function betweenLength (callback, value) {\n            var aboveMinLength = value.length >= minimumLength,\n                belowMaxLength = value.length <= maximumLength;\n\n            callback(aboveMinLength && belowMaxLength);\n        };\n    },\n\n    'max-number': function (maximumNumber) {\n        return function maxNumber (callback, value) {\n            callback(+value <= maximumNumber);\n        };\n    },\n\n    'min-number': function (minimumNumber) {\n        return function minNumber (callback, value) {\n            callback(+value >= minimumNumber);\n        };\n    },\n\n    'between-number': function (minimumNumber, maximumNumber) {\n        return function betweenNumber (callback, value) {\n            callback(+value >= minimumNumber && +value <= maximumNumber);\n        };\n    },\n\n    'integer': function () {\n        return function (callback, value) {\n            callback(/^\\s*\\d+\\s*$/.test(value));\n        };\n    },\n\n    'float': function () {\n        return function (callback, value) {\n            callback(/^[-+]?[0-9]+(\\.[0-9]+)?$/.test(value));\n        };\n    },\n\n    'same-as': function (selector) {\n        var sameAsElement = nod.getElement(selector);\n\n        return function sameAs (callback, value, options) {\n            // 'same-as' is special, in that if it is triggered by another field\n            // (the one it should be similar to), and the field itself is empty,\n            // then it bails out without a check. This is to avoid showing an\n            // error message before the user has even reached the element.\n            if (options &&\n                options.event &&\n                options.event.target &&\n                options.event.target !== options.element &&\n                value.length === 0) {\n                return;\n            }\n\n            callback(value === sameAsElement.value);\n        };\n    },\n\n    'one-of': function (selector) {\n        var elements = nod.getElements(selector);\n\n        function getValues () {\n            return elements.reduce(function (memo, element) {\n                return memo + '' + (element.value || '');\n            }, '');\n        }\n\n        return function oneOf (callback) {\n            callback(getValues().trim().length > 0);\n        };\n    },\n\n    'only-one-of': function (selector) {\n        var elements = nod.getElements(selector);\n\n        return function onlyOneOf (callback, value) {\n            var numOfValues = 0;\n\n            elements.forEach(function (element) {\n                if (element.value) {\n                    numOfValues++;\n                }\n            });\n\n            callback(numOfValues === 1);\n        };\n    },\n\n    'checked': function () {\n        return function checked (callback, value, options) {\n            callback(options.element.checked);\n        };\n    },\n\n    'some-radio': function (selector) {\n        var radioElements = nod.getElements(selector);\n\n        return function someRadio (callback, value, options) {\n            var result = radioElements.reduce(function (memo, element) {\n                return memo || element.checked;\n            }, false);\n\n            callback(result);\n        };\n    },\n\n    'regexp': function (reg) {\n        return function regExp (callback, value) {\n            callback(reg.test(value));\n        };\n    },\n\n    'email': function () {\n        var RFC822 = /^([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22))*\\x40([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d))*$/;\n\n        return function email (callback, value) {\n            callback(RFC822.test(value));\n        };\n    }\n};\n\n// CustomEvent polyfill for older IE versions. Taken from\n// github.com/d4tocchini/customevent-polyfill/blob/master/CustomEvent.js\ntry {\n    new CustomEvent(\"test\");\n} catch (e) {\n    var CustomEvent = function (event, params) {\n        var evt;\n        params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined\n        };\n\n        evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(event,\n                            params.bubbles,\n                            params.cancelable,\n                            params.detail);\n        return evt;\n    };\n\n    CustomEvent.prototype = window.Event.prototype;\n    window.CustomEvent = CustomEvent;\n}\n\n// Safely export nod.\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = nod;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nod-validate/nod.js\n// module id = 362\n// module chunks = 0 1 2 3 5 6 7 8 9 10","import $ from 'jquery';\nimport 'foundation-sites/js/foundation/foundation';\nimport 'foundation-sites/js/foundation/foundation.reveal';\nimport nod from './common/nod';\nimport PageManager from './page-manager';\nimport { api } from '@bigcommerce/stencil-utils';\nimport { defaultModal } from './global/modal';\n\nexport default class WishList extends PageManager {\n    constructor() {\n        super();\n\n        this.options = {\n            template: 'account/add-wishlist',\n        };\n    }\n\n    /**\n     * Creates a confirm box before deleting all wish lists\n     */\n    wishlistDeleteConfirm() {\n        $('body').on('click', '[data-wishlist-delete]', (event) => {\n            const confirmed = confirm(this.context.wishlistDelete);\n\n            if (confirmed) {\n                return true;\n            }\n\n            event.preventDefault();\n        });\n    }\n\n    registerAddWishListValidation($addWishlistForm) {\n        this.addWishlistValidator = nod({\n            submit: '.wishlist-form input[type=\"submit\"]',\n        });\n\n        this.addWishlistValidator.add([\n            {\n                selector: '.wishlist-form input[name=\"wishlistname\"]',\n                validate: (cb, val) => {\n                    const result = val.length > 0;\n\n                    cb(result);\n                },\n                errorMessage: 'You must enter a wishlist name.',\n            },\n        ]);\n\n        $addWishlistForm.submit((event) => {\n            this.addWishlistValidator.performCheck();\n\n            if (this.addWishlistValidator.areAll('valid')) {\n                return;\n            }\n\n            event.preventDefault();\n        });\n    }\n\n    wishListHandler() {\n        $('body').on('click', '[data-wishlist]', (event) => {\n            const wishListUrl = event.currentTarget.href;\n            const modal = defaultModal();\n\n            event.preventDefault();\n\n            modal.open();\n\n            api.getPage(wishListUrl, this.options, (err, content) => {\n                if (err) {\n                    return modal.updateContent(err);\n                }\n\n                modal.updateContent(content, { wrap: true });\n\n                const $wishlistForm = $('.wishlist-form', modal.$content);\n\n                this.registerAddWishListValidation($wishlistForm);\n            });\n        });\n    }\n\n    loaded(next) {\n        const $addWishListForm = $('.wishlist-form');\n\n        if ($addWishListForm.length) {\n            this.registerAddWishListValidation($addWishListForm);\n        }\n\n        this.wishlistDeleteConfirm();\n        this.wishListHandler();\n\n        next();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./assets/js/theme/wishlist.js"],"sourceRoot":""}